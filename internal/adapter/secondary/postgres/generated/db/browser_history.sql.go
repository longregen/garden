// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: browser_history.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countBrowserHistory = `-- name: CountBrowserHistory :one
SELECT COUNT(*)::bigint
FROM browser_history
WHERE
    ($1::text IS NULL OR (
        browser_history.title ILIKE '%' || $1::text || '%' OR
        browser_history.url ILIKE '%' || $1::text || '%'
    ))
    AND ($2::timestamp IS NULL OR browser_history.visit_date >= $2::timestamp)
    AND ($3::timestamp IS NULL OR browser_history.visit_date <= $3::timestamp)
    AND ($4::text IS NULL OR browser_history.domain = $4::text)
`

type CountBrowserHistoryParams struct {
	SearchQuery *string          `json:"search_query"`
	StartDate   pgtype.Timestamp `json:"start_date"`
	EndDate     pgtype.Timestamp `json:"end_date"`
	Domain      *string          `json:"domain"`
}

func (q *Queries) CountBrowserHistory(ctx context.Context, arg CountBrowserHistoryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countBrowserHistory,
		arg.SearchQuery,
		arg.StartDate,
		arg.EndDate,
		arg.Domain,
	)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getRecentBrowserHistory = `-- name: GetRecentBrowserHistory :many
SELECT
    browser_history.id,
    browser_history.url,
    browser_history.title,
    browser_history.visit_date,
    browser_history.typed,
    browser_history.hidden,
    browser_history.imported_from_firefox_place_id,
    browser_history.imported_from_firefox_visit_id,
    browser_history.domain,
    browser_history.created_at
FROM browser_history
ORDER BY browser_history.visit_date DESC
LIMIT $1::int
`

func (q *Queries) GetRecentBrowserHistory(ctx context.Context, historyLimit int32) ([]BrowserHistory, error) {
	rows, err := q.db.Query(ctx, getRecentBrowserHistory, historyLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BrowserHistory{}
	for rows.Next() {
		var i BrowserHistory
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.VisitDate,
			&i.Typed,
			&i.Hidden,
			&i.ImportedFromFirefoxPlaceID,
			&i.ImportedFromFirefoxVisitID,
			&i.Domain,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopDomains = `-- name: GetTopDomains :many
SELECT
    domain,
    COUNT(*)::bigint as visit_count
FROM browser_history
WHERE domain IS NOT NULL
GROUP BY domain
ORDER BY visit_count DESC
LIMIT $1::int
`

type GetTopDomainsRow struct {
	Domain     *string `json:"domain"`
	VisitCount int64   `json:"visit_count"`
}

func (q *Queries) GetTopDomains(ctx context.Context, domainLimit int32) ([]GetTopDomainsRow, error) {
	rows, err := q.db.Query(ctx, getTopDomains, domainLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopDomainsRow{}
	for rows.Next() {
		var i GetTopDomainsRow
		if err := rows.Scan(&i.Domain, &i.VisitCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBrowserHistory = `-- name: ListBrowserHistory :many
SELECT
    browser_history.id,
    browser_history.url,
    browser_history.title,
    browser_history.visit_date,
    browser_history.typed,
    browser_history.hidden,
    browser_history.imported_from_firefox_place_id,
    browser_history.imported_from_firefox_visit_id,
    browser_history.domain,
    browser_history.created_at
FROM browser_history
WHERE
    ($1::text IS NULL OR (
        browser_history.title ILIKE '%' || $1::text || '%' OR
        browser_history.url ILIKE '%' || $1::text || '%'
    ))
    AND ($2::timestamp IS NULL OR browser_history.visit_date >= $2::timestamp)
    AND ($3::timestamp IS NULL OR browser_history.visit_date <= $3::timestamp)
    AND ($4::text IS NULL OR browser_history.domain = $4::text)
ORDER BY browser_history.visit_date DESC
LIMIT $6::int
OFFSET $5::int
`

type ListBrowserHistoryParams struct {
	SearchQuery *string          `json:"search_query"`
	StartDate   pgtype.Timestamp `json:"start_date"`
	EndDate     pgtype.Timestamp `json:"end_date"`
	Domain      *string          `json:"domain"`
	PageOffset  int32            `json:"page_offset"`
	PageSize    int32            `json:"page_size"`
}

func (q *Queries) ListBrowserHistory(ctx context.Context, arg ListBrowserHistoryParams) ([]BrowserHistory, error) {
	rows, err := q.db.Query(ctx, listBrowserHistory,
		arg.SearchQuery,
		arg.StartDate,
		arg.EndDate,
		arg.Domain,
		arg.PageOffset,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BrowserHistory{}
	for rows.Next() {
		var i BrowserHistory
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.VisitDate,
			&i.Typed,
			&i.Hidden,
			&i.ImportedFromFirefoxPlaceID,
			&i.ImportedFromFirefoxVisitID,
			&i.Domain,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
