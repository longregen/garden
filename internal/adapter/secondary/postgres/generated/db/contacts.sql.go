// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: contacts.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addContactTag = `-- name: AddContactTag :exec
INSERT INTO contact_tags (contact_id, tag_id)
VALUES ($1, $2)
`

type AddContactTagParams struct {
	ContactID uuid.UUID `json:"contact_id"`
	TagID     uuid.UUID `json:"tag_id"`
}

func (q *Queries) AddContactTag(ctx context.Context, arg AddContactTagParams) error {
	_, err := q.db.Exec(ctx, addContactTag, arg.ContactID, arg.TagID)
	return err
}

const countContacts = `-- name: CountContacts :one
SELECT COUNT(*) FROM contacts
`

func (q *Queries) CountContacts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countContacts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createContact = `-- name: CreateContact :one
INSERT INTO contacts (
    name,
    email,
    phone,
    birthday,
    notes,
    extras,
    creation_date,
    last_update
) VALUES (
    $1, $2, $3, $4, $5, $6, NOW(), NOW()
) RETURNING contact_id, name, email, phone, birthday, notes, extras, creation_date, last_update
`

type CreateContactParams struct {
	Name     string  `json:"name"`
	Email    *string `json:"email"`
	Phone    *string `json:"phone"`
	Birthday *string `json:"birthday"`
	Notes    *string `json:"notes"`
	Extras   []byte  `json:"extras"`
}

type CreateContactRow struct {
	ContactID    uuid.UUID        `json:"contact_id"`
	Name         string           `json:"name"`
	Email        *string          `json:"email"`
	Phone        *string          `json:"phone"`
	Birthday     *string          `json:"birthday"`
	Notes        *string          `json:"notes"`
	Extras       []byte           `json:"extras"`
	CreationDate pgtype.Timestamp `json:"creation_date"`
	LastUpdate   pgtype.Timestamp `json:"last_update"`
}

func (q *Queries) CreateContact(ctx context.Context, arg CreateContactParams) (CreateContactRow, error) {
	row := q.db.QueryRow(ctx, createContact,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.Birthday,
		arg.Notes,
		arg.Extras,
	)
	var i CreateContactRow
	err := row.Scan(
		&i.ContactID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.Birthday,
		&i.Notes,
		&i.Extras,
		&i.CreationDate,
		&i.LastUpdate,
	)
	return i, err
}

const createContactEvaluation = `-- name: CreateContactEvaluation :exec
INSERT INTO contact_evals (
    contact_id,
    importance,
    closeness,
    fondness,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, NOW(), NOW()
)
`

type CreateContactEvaluationParams struct {
	ContactID  uuid.UUID `json:"contact_id"`
	Importance *int32    `json:"importance"`
	Closeness  *int32    `json:"closeness"`
	Fondness   *int32    `json:"fondness"`
}

func (q *Queries) CreateContactEvaluation(ctx context.Context, arg CreateContactEvaluationParams) error {
	_, err := q.db.Exec(ctx, createContactEvaluation,
		arg.ContactID,
		arg.Importance,
		arg.Closeness,
		arg.Fondness,
	)
	return err
}

const createContactSource = `-- name: CreateContactSource :one
INSERT INTO contact_sources (
    contact_id,
    source_id,
    source_name
) VALUES (
    $1, $2, $3
) RETURNING id, contact_id, source_id, source_name
`

type CreateContactSourceParams struct {
	ContactID  pgtype.UUID `json:"contact_id"`
	SourceID   string      `json:"source_id"`
	SourceName string      `json:"source_name"`
}

func (q *Queries) CreateContactSource(ctx context.Context, arg CreateContactSourceParams) (ContactSource, error) {
	row := q.db.QueryRow(ctx, createContactSource, arg.ContactID, arg.SourceID, arg.SourceName)
	var i ContactSource
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.SourceID,
		&i.SourceName,
	)
	return i, err
}

const createTagName = `-- name: CreateTagName :one
INSERT INTO contact_tagnames (name, created_at)
VALUES ($1, NOW())
RETURNING tag_id, name
`

type CreateTagNameRow struct {
	TagID uuid.UUID `json:"tag_id"`
	Name  string    `json:"name"`
}

func (q *Queries) CreateTagName(ctx context.Context, name string) (CreateTagNameRow, error) {
	row := q.db.QueryRow(ctx, createTagName, name)
	var i CreateTagNameRow
	err := row.Scan(&i.TagID, &i.Name)
	return i, err
}

const deleteContact = `-- name: DeleteContact :exec
DELETE FROM contacts WHERE contact_id = $1
`

func (q *Queries) DeleteContact(ctx context.Context, contactID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteContact, contactID)
	return err
}

const deleteContactSource = `-- name: DeleteContactSource :exec
DELETE FROM contact_sources WHERE id = $1
`

func (q *Queries) DeleteContactSource(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteContactSource, id)
	return err
}

const ensureContactStatsExist = `-- name: EnsureContactStatsExist :exec
INSERT INTO contact_stats (contact_id)
SELECT contact_id FROM contacts
WHERE NOT EXISTS (
    SELECT 1 FROM contact_stats
    WHERE contact_stats.contact_id = contacts.contact_id
)
`

func (q *Queries) EnsureContactStatsExist(ctx context.Context) error {
	_, err := q.db.Exec(ctx, ensureContactStatsExist)
	return err
}

const getAllTagNames = `-- name: GetAllTagNames :many
SELECT tag_id, name
FROM contact_tagnames
ORDER BY name
`

type GetAllTagNamesRow struct {
	TagID uuid.UUID `json:"tag_id"`
	Name  string    `json:"name"`
}

func (q *Queries) GetAllTagNames(ctx context.Context) ([]GetAllTagNamesRow, error) {
	rows, err := q.db.Query(ctx, getAllTagNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllTagNamesRow{}
	for rows.Next() {
		var i GetAllTagNamesRow
		if err := rows.Scan(&i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContact = `-- name: GetContact :one
SELECT
    c.contact_id,
    c.name,
    c.email,
    c.phone,
    c.birthday,
    c.notes,
    c.extras,
    c.creation_date,
    c.last_update,
    cs.last_week_messages,
    cs.groups_in_common
FROM contacts c
LEFT JOIN contact_stats cs ON c.contact_id = cs.contact_id
WHERE c.contact_id = $1
`

type GetContactRow struct {
	ContactID        uuid.UUID        `json:"contact_id"`
	Name             string           `json:"name"`
	Email            *string          `json:"email"`
	Phone            *string          `json:"phone"`
	Birthday         *string          `json:"birthday"`
	Notes            *string          `json:"notes"`
	Extras           []byte           `json:"extras"`
	CreationDate     pgtype.Timestamp `json:"creation_date"`
	LastUpdate       pgtype.Timestamp `json:"last_update"`
	LastWeekMessages *int32           `json:"last_week_messages"`
	GroupsInCommon   *int32           `json:"groups_in_common"`
}

func (q *Queries) GetContact(ctx context.Context, contactID uuid.UUID) (GetContactRow, error) {
	row := q.db.QueryRow(ctx, getContact, contactID)
	var i GetContactRow
	err := row.Scan(
		&i.ContactID,
		&i.Name,
		&i.Email,
		&i.Phone,
		&i.Birthday,
		&i.Notes,
		&i.Extras,
		&i.CreationDate,
		&i.LastUpdate,
		&i.LastWeekMessages,
		&i.GroupsInCommon,
	)
	return i, err
}

const getContactEvaluation = `-- name: GetContactEvaluation :one
SELECT
    id,
    contact_id,
    importance,
    closeness,
    fondness,
    created_at,
    updated_at
FROM contact_evals
WHERE contact_id = $1
`

func (q *Queries) GetContactEvaluation(ctx context.Context, contactID uuid.UUID) (ContactEval, error) {
	row := q.db.QueryRow(ctx, getContactEvaluation, contactID)
	var i ContactEval
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.Importance,
		&i.Closeness,
		&i.Fondness,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getContactEvaluationExists = `-- name: GetContactEvaluationExists :one
SELECT EXISTS(SELECT 1 FROM contact_evals WHERE contact_id = $1)
`

func (q *Queries) GetContactEvaluationExists(ctx context.Context, contactID uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, getContactEvaluationExists, contactID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getContactEvaluationsByContactIds = `-- name: GetContactEvaluationsByContactIds :many
SELECT
    contact_id,
    importance,
    closeness,
    fondness
FROM contact_evals
WHERE contact_id = ANY($1::uuid[])
`

type GetContactEvaluationsByContactIdsRow struct {
	ContactID  uuid.UUID `json:"contact_id"`
	Importance *int32    `json:"importance"`
	Closeness  *int32    `json:"closeness"`
	Fondness   *int32    `json:"fondness"`
}

func (q *Queries) GetContactEvaluationsByContactIds(ctx context.Context, dollar_1 []uuid.UUID) ([]GetContactEvaluationsByContactIdsRow, error) {
	rows, err := q.db.Query(ctx, getContactEvaluationsByContactIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContactEvaluationsByContactIdsRow{}
	for rows.Next() {
		var i GetContactEvaluationsByContactIdsRow
		if err := rows.Scan(
			&i.ContactID,
			&i.Importance,
			&i.Closeness,
			&i.Fondness,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContactKnownNames = `-- name: GetContactKnownNames :many
SELECT
    id,
    contact_id,
    name
FROM contact_known_names
WHERE contact_id = $1
`

func (q *Queries) GetContactKnownNames(ctx context.Context, contactID uuid.UUID) ([]ContactKnownName, error) {
	rows, err := q.db.Query(ctx, getContactKnownNames, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContactKnownName{}
	for rows.Next() {
		var i ContactKnownName
		if err := rows.Scan(&i.ID, &i.ContactID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContactRooms = `-- name: GetContactRooms :many
SELECT
    r.room_id,
    r.display_name,
    r.user_defined_name
FROM room_participants rp
INNER JOIN rooms r ON rp.room_id = r.room_id
WHERE rp.contact_id = $1
`

type GetContactRoomsRow struct {
	RoomID          uuid.UUID `json:"room_id"`
	DisplayName     *string   `json:"display_name"`
	UserDefinedName *string   `json:"user_defined_name"`
}

func (q *Queries) GetContactRooms(ctx context.Context, contactID uuid.UUID) ([]GetContactRoomsRow, error) {
	rows, err := q.db.Query(ctx, getContactRooms, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContactRoomsRow{}
	for rows.Next() {
		var i GetContactRoomsRow
		if err := rows.Scan(&i.RoomID, &i.DisplayName, &i.UserDefinedName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContactSources = `-- name: GetContactSources :many
SELECT
    id,
    contact_id,
    source_id,
    source_name
FROM contact_sources
WHERE contact_id = $1
`

func (q *Queries) GetContactSources(ctx context.Context, contactID pgtype.UUID) ([]ContactSource, error) {
	rows, err := q.db.Query(ctx, getContactSources, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContactSource{}
	for rows.Next() {
		var i ContactSource
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.SourceID,
			&i.SourceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContactTagByName = `-- name: GetContactTagByName :one
SELECT tag_id, name
FROM contact_tagnames
WHERE name = $1
`

type GetContactTagByNameRow struct {
	TagID uuid.UUID `json:"tag_id"`
	Name  string    `json:"name"`
}

func (q *Queries) GetContactTagByName(ctx context.Context, name string) (GetContactTagByNameRow, error) {
	row := q.db.QueryRow(ctx, getContactTagByName, name)
	var i GetContactTagByNameRow
	err := row.Scan(&i.TagID, &i.Name)
	return i, err
}

const getContactTagExists = `-- name: GetContactTagExists :one
SELECT EXISTS(
    SELECT 1 FROM contact_tags
    WHERE contact_id = $1 AND tag_id = $2
)
`

type GetContactTagExistsParams struct {
	ContactID uuid.UUID `json:"contact_id"`
	TagID     uuid.UUID `json:"tag_id"`
}

func (q *Queries) GetContactTagExists(ctx context.Context, arg GetContactTagExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, getContactTagExists, arg.ContactID, arg.TagID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getContactTags = `-- name: GetContactTags :many
SELECT
    ctn.tag_id,
    ctn.name
FROM contact_tags ct
INNER JOIN contact_tagnames ctn ON ct.tag_id = ctn.tag_id
WHERE ct.contact_id = $1
`

type GetContactTagsRow struct {
	TagID uuid.UUID `json:"tag_id"`
	Name  string    `json:"name"`
}

func (q *Queries) GetContactTags(ctx context.Context, contactID uuid.UUID) ([]GetContactTagsRow, error) {
	rows, err := q.db.Query(ctx, getContactTags, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContactTagsRow{}
	for rows.Next() {
		var i GetContactTagsRow
		if err := rows.Scan(&i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContactTagsByContactIds = `-- name: GetContactTagsByContactIds :many
SELECT
    ct.contact_id,
    ctn.tag_id,
    ctn.name
FROM contact_tags ct
INNER JOIN contact_tagnames ctn ON ct.tag_id = ctn.tag_id
WHERE ct.contact_id = ANY($1::uuid[])
`

type GetContactTagsByContactIdsRow struct {
	ContactID uuid.UUID `json:"contact_id"`
	TagID     uuid.UUID `json:"tag_id"`
	Name      string    `json:"name"`
}

func (q *Queries) GetContactTagsByContactIds(ctx context.Context, dollar_1 []uuid.UUID) ([]GetContactTagsByContactIdsRow, error) {
	rows, err := q.db.Query(ctx, getContactTagsByContactIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContactTagsByContactIdsRow{}
	for rows.Next() {
		var i GetContactTagsByContactIdsRow
		if err := rows.Scan(&i.ContactID, &i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllContactSources = `-- name: ListAllContactSources :many
SELECT
    id,
    contact_id,
    source_id,
    source_name
FROM contact_sources
ORDER BY source_name
`

func (q *Queries) ListAllContactSources(ctx context.Context) ([]ContactSource, error) {
	rows, err := q.db.Query(ctx, listAllContactSources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContactSource{}
	for rows.Next() {
		var i ContactSource
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.SourceID,
			&i.SourceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContacts = `-- name: ListContacts :many
SELECT
    c.contact_id,
    c.name,
    c.email,
    c.phone,
    c.birthday,
    c.notes,
    c.extras,
    c.creation_date,
    c.last_update,
    cs.last_week_messages,
    cs.groups_in_common
FROM contacts c
LEFT JOIN contact_stats cs ON c.contact_id = cs.contact_id
WHERE c.contact_id != '5f78a1e9-f68b-445a-8d97-63111a877fe0'
ORDER BY cs.last_week_messages DESC NULLS LAST
LIMIT $1 OFFSET $2
`

type ListContactsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListContactsRow struct {
	ContactID        uuid.UUID        `json:"contact_id"`
	Name             string           `json:"name"`
	Email            *string          `json:"email"`
	Phone            *string          `json:"phone"`
	Birthday         *string          `json:"birthday"`
	Notes            *string          `json:"notes"`
	Extras           []byte           `json:"extras"`
	CreationDate     pgtype.Timestamp `json:"creation_date"`
	LastUpdate       pgtype.Timestamp `json:"last_update"`
	LastWeekMessages *int32           `json:"last_week_messages"`
	GroupsInCommon   *int32           `json:"groups_in_common"`
}

func (q *Queries) ListContacts(ctx context.Context, arg ListContactsParams) ([]ListContactsRow, error) {
	rows, err := q.db.Query(ctx, listContacts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListContactsRow{}
	for rows.Next() {
		var i ListContactsRow
		if err := rows.Scan(
			&i.ContactID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Birthday,
			&i.Notes,
			&i.Extras,
			&i.CreationDate,
			&i.LastUpdate,
			&i.LastWeekMessages,
			&i.GroupsInCommon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergeContacts = `-- name: MergeContacts :exec
CALL merge_contacts($1::uuid, $2::uuid)
`

type MergeContactsParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 uuid.UUID `json:"column_2"`
}

func (q *Queries) MergeContacts(ctx context.Context, arg MergeContactsParams) error {
	_, err := q.db.Exec(ctx, mergeContacts, arg.Column1, arg.Column2)
	return err
}

const removeContactTag = `-- name: RemoveContactTag :exec
DELETE FROM contact_tags
WHERE contact_id = $1 AND tag_id = $2
`

type RemoveContactTagParams struct {
	ContactID uuid.UUID `json:"contact_id"`
	TagID     uuid.UUID `json:"tag_id"`
}

func (q *Queries) RemoveContactTag(ctx context.Context, arg RemoveContactTagParams) error {
	_, err := q.db.Exec(ctx, removeContactTag, arg.ContactID, arg.TagID)
	return err
}

const searchContacts = `-- name: SearchContacts :many
SELECT
    c.contact_id,
    c.name,
    c.email,
    c.phone,
    c.birthday,
    c.notes,
    c.extras,
    c.creation_date,
    c.last_update,
    cs.last_week_messages,
    cs.groups_in_common
FROM contacts c
LEFT JOIN contact_stats cs ON c.contact_id = cs.contact_id
WHERE c.contact_id != '5f78a1e9-f68b-445a-8d97-63111a877fe0'
  AND (c.name ILIKE $1 OR c.email ILIKE $1)
ORDER BY cs.last_week_messages DESC NULLS LAST
LIMIT $2 OFFSET $3
`

type SearchContactsParams struct {
	Name   string `json:"name"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type SearchContactsRow struct {
	ContactID        uuid.UUID        `json:"contact_id"`
	Name             string           `json:"name"`
	Email            *string          `json:"email"`
	Phone            *string          `json:"phone"`
	Birthday         *string          `json:"birthday"`
	Notes            *string          `json:"notes"`
	Extras           []byte           `json:"extras"`
	CreationDate     pgtype.Timestamp `json:"creation_date"`
	LastUpdate       pgtype.Timestamp `json:"last_update"`
	LastWeekMessages *int32           `json:"last_week_messages"`
	GroupsInCommon   *int32           `json:"groups_in_common"`
}

func (q *Queries) SearchContacts(ctx context.Context, arg SearchContactsParams) ([]SearchContactsRow, error) {
	rows, err := q.db.Query(ctx, searchContacts, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchContactsRow{}
	for rows.Next() {
		var i SearchContactsRow
		if err := rows.Scan(
			&i.ContactID,
			&i.Name,
			&i.Email,
			&i.Phone,
			&i.Birthday,
			&i.Notes,
			&i.Extras,
			&i.CreationDate,
			&i.LastUpdate,
			&i.LastWeekMessages,
			&i.GroupsInCommon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateContact = `-- name: UpdateContact :exec
UPDATE contacts
SET
    name = COALESCE($2, name),
    email = COALESCE($3, email),
    phone = COALESCE($4, phone),
    birthday = COALESCE($5, birthday),
    notes = COALESCE($6, notes),
    extras = COALESCE($7, extras),
    last_update = NOW()
WHERE contact_id = $1
`

type UpdateContactParams struct {
	ContactID uuid.UUID `json:"contact_id"`
	Name      string    `json:"name"`
	Email     *string   `json:"email"`
	Phone     *string   `json:"phone"`
	Birthday  *string   `json:"birthday"`
	Notes     *string   `json:"notes"`
	Extras    []byte    `json:"extras"`
}

func (q *Queries) UpdateContact(ctx context.Context, arg UpdateContactParams) error {
	_, err := q.db.Exec(ctx, updateContact,
		arg.ContactID,
		arg.Name,
		arg.Email,
		arg.Phone,
		arg.Birthday,
		arg.Notes,
		arg.Extras,
	)
	return err
}

const updateContactEvaluation = `-- name: UpdateContactEvaluation :exec
UPDATE contact_evals
SET
    importance = COALESCE($2, importance),
    closeness = COALESCE($3, closeness),
    fondness = COALESCE($4, fondness),
    updated_at = NOW()
WHERE contact_id = $1
`

type UpdateContactEvaluationParams struct {
	ContactID  uuid.UUID `json:"contact_id"`
	Importance *int32    `json:"importance"`
	Closeness  *int32    `json:"closeness"`
	Fondness   *int32    `json:"fondness"`
}

func (q *Queries) UpdateContactEvaluation(ctx context.Context, arg UpdateContactEvaluationParams) error {
	_, err := q.db.Exec(ctx, updateContactEvaluation,
		arg.ContactID,
		arg.Importance,
		arg.Closeness,
		arg.Fondness,
	)
	return err
}

const updateContactFields = `-- name: UpdateContactFields :exec
UPDATE contacts
SET last_update = NOW()
WHERE contact_id = $1
`

func (q *Queries) UpdateContactFields(ctx context.Context, contactID uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateContactFields, contactID)
	return err
}

const updateContactMessageStats = `-- name: UpdateContactMessageStats :exec
UPDATE contact_stats
SET last_week_messages = (
    SELECT COUNT(message_id)
    FROM messages
    WHERE sender_contact_id = contact_stats.contact_id
      AND event_datetime > NOW() - INTERVAL '7 days'
)
`

func (q *Queries) UpdateContactMessageStats(ctx context.Context) error {
	_, err := q.db.Exec(ctx, updateContactMessageStats)
	return err
}

const updateContactSource = `-- name: UpdateContactSource :one
UPDATE contact_sources
SET
    source_id = $2,
    source_name = $3
WHERE id = $1
RETURNING id, contact_id, source_id, source_name
`

type UpdateContactSourceParams struct {
	ID         uuid.UUID `json:"id"`
	SourceID   string    `json:"source_id"`
	SourceName string    `json:"source_name"`
}

func (q *Queries) UpdateContactSource(ctx context.Context, arg UpdateContactSourceParams) (ContactSource, error) {
	row := q.db.QueryRow(ctx, updateContactSource, arg.ID, arg.SourceID, arg.SourceName)
	var i ContactSource
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.SourceID,
		&i.SourceName,
	)
	return i, err
}
