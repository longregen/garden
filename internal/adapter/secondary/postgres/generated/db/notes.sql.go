// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: notes.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const countNotes = `-- name: CountNotes :one
SELECT COUNT(*) FROM items
`

func (q *Queries) CountNotes(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countNotes)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSearchNotes = `-- name: CountSearchNotes :one
SELECT COUNT(*) FROM items
WHERE title ILIKE $1 OR contents ILIKE $1
`

func (q *Queries) CountSearchNotes(ctx context.Context, title *string) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchNotes, title)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEntityForNote = `-- name: CreateEntityForNote :one
INSERT INTO entities (
    name,
    type,
    description,
    properties,
    updated_at
) VALUES (
    $1, $2, $3, $4, CURRENT_TIMESTAMP
) RETURNING entity_id, name, type, description, properties, created_at, updated_at
`

type CreateEntityForNoteParams struct {
	Name        string  `json:"name"`
	Type        string  `json:"type"`
	Description *string `json:"description"`
	Properties  []byte  `json:"properties"`
}

type CreateEntityForNoteRow struct {
	EntityID    uuid.UUID        `json:"entity_id"`
	Name        string           `json:"name"`
	Type        string           `json:"type"`
	Description *string          `json:"description"`
	Properties  []byte           `json:"properties"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) CreateEntityForNote(ctx context.Context, arg CreateEntityForNoteParams) (CreateEntityForNoteRow, error) {
	row := q.db.QueryRow(ctx, createEntityForNote,
		arg.Name,
		arg.Type,
		arg.Description,
		arg.Properties,
	)
	var i CreateEntityForNoteRow
	err := row.Scan(
		&i.EntityID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEntityReference = `-- name: CreateEntityReference :exec
INSERT INTO entity_references (
    source_type,
    source_id,
    entity_id,
    reference_text,
    position
) VALUES (
    $1, $2, $3, $4, $5
)
`

type CreateEntityReferenceParams struct {
	SourceType    string    `json:"source_type"`
	SourceID      uuid.UUID `json:"source_id"`
	EntityID      uuid.UUID `json:"entity_id"`
	ReferenceText string    `json:"reference_text"`
	Position      *int32    `json:"position"`
}

func (q *Queries) CreateEntityReference(ctx context.Context, arg CreateEntityReferenceParams) error {
	_, err := q.db.Exec(ctx, createEntityReference,
		arg.SourceType,
		arg.SourceID,
		arg.EntityID,
		arg.ReferenceText,
		arg.Position,
	)
	return err
}

const createEntityRelationshipForNote = `-- name: CreateEntityRelationshipForNote :exec
INSERT INTO entity_relationships (
    entity_id,
    related_type,
    related_id,
    relationship_type,
    metadata,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, CURRENT_TIMESTAMP
)
`

type CreateEntityRelationshipForNoteParams struct {
	EntityID         uuid.UUID `json:"entity_id"`
	RelatedType      string    `json:"related_type"`
	RelatedID        uuid.UUID `json:"related_id"`
	RelationshipType string    `json:"relationship_type"`
	Metadata         []byte    `json:"metadata"`
}

func (q *Queries) CreateEntityRelationshipForNote(ctx context.Context, arg CreateEntityRelationshipForNoteParams) error {
	_, err := q.db.Exec(ctx, createEntityRelationshipForNote,
		arg.EntityID,
		arg.RelatedType,
		arg.RelatedID,
		arg.RelationshipType,
		arg.Metadata,
	)
	return err
}

const createItemTag = `-- name: CreateItemTag :exec
INSERT INTO item_tags (item_id, tag_id)
VALUES ($1, $2)
`

type CreateItemTagParams struct {
	ItemID uuid.UUID `json:"item_id"`
	TagID  uuid.UUID `json:"tag_id"`
}

func (q *Queries) CreateItemTag(ctx context.Context, arg CreateItemTagParams) error {
	_, err := q.db.Exec(ctx, createItemTag, arg.ItemID, arg.TagID)
	return err
}

const createNote = `-- name: CreateNote :one
INSERT INTO items (
    title,
    slug,
    contents,
    created,
    modified
) VALUES (
    $1, $2, $3,
    EXTRACT(epoch FROM CURRENT_TIMESTAMP),
    EXTRACT(epoch FROM CURRENT_TIMESTAMP)
) RETURNING id, title, slug, contents, created, modified
`

type CreateNoteParams struct {
	Title    *string `json:"title"`
	Slug     *string `json:"slug"`
	Contents *string `json:"contents"`
}

func (q *Queries) CreateNote(ctx context.Context, arg CreateNoteParams) (Item, error) {
	row := q.db.QueryRow(ctx, createNote, arg.Title, arg.Slug, arg.Contents)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Contents,
		&i.Created,
		&i.Modified,
	)
	return i, err
}

const deleteEntityRelationships = `-- name: DeleteEntityRelationships :exec
DELETE FROM entity_relationships
WHERE entity_id = $1
`

func (q *Queries) DeleteEntityRelationships(ctx context.Context, entityID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEntityRelationships, entityID)
	return err
}

const deleteNote = `-- name: DeleteNote :exec
DELETE FROM items WHERE id = $1
`

func (q *Queries) DeleteNote(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteNote, id)
	return err
}

const deleteNoteEntityReferences = `-- name: DeleteNoteEntityReferences :exec
DELETE FROM entity_references
WHERE source_type = 'note' AND source_id = $1
`

func (q *Queries) DeleteNoteEntityReferences(ctx context.Context, sourceID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteNoteEntityReferences, sourceID)
	return err
}

const deleteNoteItemTags = `-- name: DeleteNoteItemTags :exec
DELETE FROM item_tags WHERE item_id = $1
`

func (q *Queries) DeleteNoteItemTags(ctx context.Context, itemID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteNoteItemTags, itemID)
	return err
}

const deleteNoteSemanticIndex = `-- name: DeleteNoteSemanticIndex :exec
DELETE FROM item_semantic_index WHERE item_id = $1
`

func (q *Queries) DeleteNoteSemanticIndex(ctx context.Context, itemID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteNoteSemanticIndex, itemID)
	return err
}

const getAllNoteTags = `-- name: GetAllNoteTags :many
SELECT id, name, last_activity, created, modified
FROM tags
ORDER BY last_activity DESC NULLS LAST
`

type GetAllNoteTagsRow struct {
	ID           uuid.UUID `json:"id"`
	Name         string    `json:"name"`
	LastActivity *int64    `json:"last_activity"`
	Created      *int64    `json:"created"`
	Modified     *int64    `json:"modified"`
}

func (q *Queries) GetAllNoteTags(ctx context.Context) ([]GetAllNoteTagsRow, error) {
	rows, err := q.db.Query(ctx, getAllNoteTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllNoteTagsRow{}
	for rows.Next() {
		var i GetAllNoteTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.LastActivity,
			&i.Created,
			&i.Modified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityByID = `-- name: GetEntityByID :one
SELECT entity_id, name, type, description, properties, created_at, updated_at, deleted_at
FROM entities
WHERE entity_id = $1
`

func (q *Queries) GetEntityByID(ctx context.Context, entityID uuid.UUID) (Entity, error) {
	row := q.db.QueryRow(ctx, getEntityByID, entityID)
	var i Entity
	err := row.Scan(
		&i.EntityID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getEntityByName = `-- name: GetEntityByName :one
SELECT entity_id, name, type, description, properties, created_at, updated_at, deleted_at
FROM entities
WHERE name = $1
  AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetEntityByName(ctx context.Context, name string) (Entity, error) {
	row := q.db.QueryRow(ctx, getEntityByName, name)
	var i Entity
	err := row.Scan(
		&i.EntityID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getNote = `-- name: GetNote :one
SELECT
    i.id,
    i.title,
    i.slug,
    i.contents,
    i.created,
    i.modified
FROM items i
WHERE i.id = $1
`

func (q *Queries) GetNote(ctx context.Context, id uuid.UUID) (Item, error) {
	row := q.db.QueryRow(ctx, getNote, id)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Contents,
		&i.Created,
		&i.Modified,
	)
	return i, err
}

const getNoteEntityRelationship = `-- name: GetNoteEntityRelationship :one
SELECT entity_id
FROM entity_relationships
WHERE related_type = 'item'
  AND related_id = $1
  AND relationship_type = 'identity'
LIMIT 1
`

func (q *Queries) GetNoteEntityRelationship(ctx context.Context, relatedID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getNoteEntityRelationship, relatedID)
	var entity_id uuid.UUID
	err := row.Scan(&entity_id)
	return entity_id, err
}

const getNoteEntityRelationshipForDelete = `-- name: GetNoteEntityRelationshipForDelete :one
SELECT entity_id
FROM entity_relationships
WHERE related_type = 'item'
  AND related_id = $1
  AND relationship_type = 'identity'
LIMIT 1
`

func (q *Queries) GetNoteEntityRelationshipForDelete(ctx context.Context, relatedID uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getNoteEntityRelationshipForDelete, relatedID)
	var entity_id uuid.UUID
	err := row.Scan(&entity_id)
	return entity_id, err
}

const getNoteTagByName = `-- name: GetNoteTagByName :one
SELECT id, name, created, modified, last_activity
FROM tags
WHERE name = $1
LIMIT 1
`

// Tags operations (specific to items/notes)
func (q *Queries) GetNoteTagByName(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRow(ctx, getNoteTagByName, name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Created,
		&i.Modified,
		&i.LastActivity,
	)
	return i, err
}

const getNoteWithTags = `-- name: GetNoteWithTags :one
SELECT
    i.id,
    i.title,
    i.slug,
    i.contents,
    i.created,
    i.modified,
    array_agg(DISTINCT t.name) FILTER (WHERE t.name IS NOT NULL) as tags
FROM items i
LEFT JOIN item_tags it ON i.id = it.item_id
LEFT JOIN tags t ON it.tag_id = t.id
WHERE i.id = $1
GROUP BY i.id, i.title, i.slug, i.contents, i.created, i.modified
`

type GetNoteWithTagsRow struct {
	ID       uuid.UUID   `json:"id"`
	Title    *string     `json:"title"`
	Slug     *string     `json:"slug"`
	Contents *string     `json:"contents"`
	Created  *int64      `json:"created"`
	Modified *int64      `json:"modified"`
	Tags     interface{} `json:"tags"`
}

func (q *Queries) GetNoteWithTags(ctx context.Context, id uuid.UUID) (GetNoteWithTagsRow, error) {
	row := q.db.QueryRow(ctx, getNoteWithTags, id)
	var i GetNoteWithTagsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Contents,
		&i.Created,
		&i.Modified,
		&i.Tags,
	)
	return i, err
}

const listNotes = `-- name: ListNotes :many
SELECT
    i.id,
    i.title,
    i.created,
    i.modified,
    array_agg(DISTINCT t.name) FILTER (WHERE t.name IS NOT NULL) as tags
FROM items i
LEFT JOIN item_tags it ON i.id = it.item_id
LEFT JOIN tags t ON it.tag_id = t.id
GROUP BY i.id, i.title, i.created, i.modified
ORDER BY i.modified DESC
LIMIT $1 OFFSET $2
`

type ListNotesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListNotesRow struct {
	ID       uuid.UUID   `json:"id"`
	Title    *string     `json:"title"`
	Created  *int64      `json:"created"`
	Modified *int64      `json:"modified"`
	Tags     interface{} `json:"tags"`
}

func (q *Queries) ListNotes(ctx context.Context, arg ListNotesParams) ([]ListNotesRow, error) {
	rows, err := q.db.Query(ctx, listNotes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListNotesRow{}
	for rows.Next() {
		var i ListNotesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Created,
			&i.Modified,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchNotes = `-- name: SearchNotes :many
SELECT
    i.id,
    i.title,
    i.created,
    i.modified,
    array_agg(DISTINCT t.name) FILTER (WHERE t.name IS NOT NULL) as tags
FROM items i
LEFT JOIN item_tags it ON i.id = it.item_id
LEFT JOIN tags t ON it.tag_id = t.id
WHERE i.title ILIKE $1 OR i.contents ILIKE $1
GROUP BY i.id, i.title, i.created, i.modified
ORDER BY i.modified DESC
LIMIT $2 OFFSET $3
`

type SearchNotesParams struct {
	Title  *string `json:"title"`
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
}

type SearchNotesRow struct {
	ID       uuid.UUID   `json:"id"`
	Title    *string     `json:"title"`
	Created  *int64      `json:"created"`
	Modified *int64      `json:"modified"`
	Tags     interface{} `json:"tags"`
}

func (q *Queries) SearchNotes(ctx context.Context, arg SearchNotesParams) ([]SearchNotesRow, error) {
	rows, err := q.db.Query(ctx, searchNotes, arg.Title, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchNotesRow{}
	for rows.Next() {
		var i SearchNotesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Created,
			&i.Modified,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSimilarNotes = `-- name: SearchSimilarNotes :many
SELECT
    i.id,
    i.title,
    i.created,
    i.modified,
    array_agg(DISTINCT t.name) FILTER (WHERE t.name IS NOT NULL) as tags
FROM items i
INNER JOIN item_semantic_index isi ON i.id = isi.item_id
LEFT JOIN item_tags it ON i.id = it.item_id
LEFT JOIN tags t ON it.tag_id = t.id
GROUP BY i.id, i.title, i.created, i.modified, isi.embedding
ORDER BY isi.embedding <=> $1::vector
LIMIT $2
`

type SearchSimilarNotesParams struct {
	Column1 *pgvector.Vector `json:"column_1"`
	Limit   int32            `json:"limit"`
}

type SearchSimilarNotesRow struct {
	ID       uuid.UUID   `json:"id"`
	Title    *string     `json:"title"`
	Created  *int64      `json:"created"`
	Modified *int64      `json:"modified"`
	Tags     interface{} `json:"tags"`
}

func (q *Queries) SearchSimilarNotes(ctx context.Context, arg SearchSimilarNotesParams) ([]SearchSimilarNotesRow, error) {
	rows, err := q.db.Query(ctx, searchSimilarNotes, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchSimilarNotesRow{}
	for rows.Next() {
		var i SearchSimilarNotesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Created,
			&i.Modified,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteEntity = `-- name: SoftDeleteEntity :exec
UPDATE entities
SET
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE entity_id = $1
`

func (q *Queries) SoftDeleteEntity(ctx context.Context, entityID uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteEntity, entityID)
	return err
}

const updateNote = `-- name: UpdateNote :exec
UPDATE items
SET
    title = $2,
    contents = $3,
    modified = EXTRACT(epoch FROM CURRENT_TIMESTAMP)
WHERE id = $1
`

type UpdateNoteParams struct {
	ID       uuid.UUID `json:"id"`
	Title    *string   `json:"title"`
	Contents *string   `json:"contents"`
}

func (q *Queries) UpdateNote(ctx context.Context, arg UpdateNoteParams) error {
	_, err := q.db.Exec(ctx, updateNote, arg.ID, arg.Title, arg.Contents)
	return err
}

const upsertNoteTag = `-- name: UpsertNoteTag :one
INSERT INTO tags (
    name,
    created,
    modified,
    last_activity
) VALUES (
    $1,
    EXTRACT(epoch FROM CURRENT_TIMESTAMP),
    EXTRACT(epoch FROM CURRENT_TIMESTAMP),
    $2
)
ON CONFLICT (name) DO UPDATE
SET
    last_activity = $2,
    modified = EXTRACT(epoch FROM CURRENT_TIMESTAMP)
RETURNING id, name, created, modified, last_activity
`

type UpsertNoteTagParams struct {
	Name         string `json:"name"`
	LastActivity *int64 `json:"last_activity"`
}

func (q *Queries) UpsertNoteTag(ctx context.Context, arg UpsertNoteTagParams) (Tag, error) {
	row := q.db.QueryRow(ctx, upsertNoteTag, arg.Name, arg.LastActivity)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Created,
		&i.Modified,
		&i.LastActivity,
	)
	return i, err
}
