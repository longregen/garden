// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: messages.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getAllMessageContents = `-- name: GetAllMessageContents :many
SELECT content
FROM raw_messages
`

func (q *Queries) GetAllMessageContents(ctx context.Context) ([][]byte, error) {
	rows, err := q.db.Query(ctx, getAllMessageContents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := [][]byte{}
	for rows.Next() {
		var content []byte
		if err := rows.Scan(&content); err != nil {
			return nil, err
		}
		items = append(items, content)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBeforeMessageDatetime = `-- name: GetBeforeMessageDatetime :one
SELECT event_datetime
FROM messages
WHERE message_id = $1
`

func (q *Queries) GetBeforeMessageDatetime(ctx context.Context, messageID uuid.UUID) (pgtype.Timestamp, error) {
	row := q.db.QueryRow(ctx, getBeforeMessageDatetime, messageID)
	var event_datetime pgtype.Timestamp
	err := row.Scan(&event_datetime)
	return event_datetime, err
}

const getContextMessages = `-- name: GetContextMessages :many
WITH matched_messages AS (
    SELECT message_id, event_datetime, room_id
    FROM messages
    WHERE message_id = ANY($2::uuid[])
        AND messages.room_id = $1
),
context_messages AS (
    SELECT DISTINCT m.message_id
    FROM messages m
    CROSS JOIN matched_messages mm
    WHERE m.room_id = $1
        AND (
            (m.event_datetime < mm.event_datetime
             AND m.message_id IN (
                 SELECT message_id
                 FROM messages
                 WHERE room_id = $1
                     AND event_datetime < mm.event_datetime
                 ORDER BY event_datetime DESC
                 LIMIT $3
             ))
            OR
            (m.event_datetime > mm.event_datetime
             AND m.message_id IN (
                 SELECT message_id
                 FROM messages
                 WHERE room_id = $1
                     AND event_datetime > mm.event_datetime
                 ORDER BY event_datetime ASC
                 LIMIT $4
             ))
        )
)
SELECT
    m.message_id,
    m.sender_contact_id,
    m.event_id,
    m.event_datetime,
    m.body,
    m.formatted_body,
    m.message_type,
    m.message_classification,
    o.data AS transcription_data,
    b.bookmark_id,
    b.url AS bookmark_url,
    bt.title AS bookmark_title,
    bcr.content AS bookmark_summary
FROM messages m
LEFT JOIN observations o ON o.ref = m.message_id AND o.type = 'transcription'
LEFT JOIN bookmark_sources bs ON bs.source_uri = m.event_id
LEFT JOIN bookmarks b ON b.bookmark_id = bs.bookmark_id
LEFT JOIN bookmark_titles bt ON bt.bookmark_id = b.bookmark_id
LEFT JOIN bookmark_content_references bcr ON bcr.bookmark_id = b.bookmark_id
    AND bcr.strategy = 'summary-reader'
WHERE m.message_id IN (SELECT message_id FROM context_messages)
ORDER BY m.event_datetime DESC
`

type GetContextMessagesParams struct {
	RoomID  uuid.UUID   `json:"room_id"`
	Column2 []uuid.UUID `json:"column_2"`
	Limit   int32       `json:"limit"`
	Limit_2 int32       `json:"limit_2"`
}

type GetContextMessagesRow struct {
	MessageID             uuid.UUID        `json:"message_id"`
	SenderContactID       uuid.UUID        `json:"sender_contact_id"`
	EventID               string           `json:"event_id"`
	EventDatetime         pgtype.Timestamp `json:"event_datetime"`
	Body                  *string          `json:"body"`
	FormattedBody         *string          `json:"formatted_body"`
	MessageType           *string          `json:"message_type"`
	MessageClassification *string          `json:"message_classification"`
	TranscriptionData     []byte           `json:"transcription_data"`
	BookmarkID            pgtype.UUID      `json:"bookmark_id"`
	BookmarkUrl           *string          `json:"bookmark_url"`
	BookmarkTitle         *string          `json:"bookmark_title"`
	BookmarkSummary       *string          `json:"bookmark_summary"`
}

func (q *Queries) GetContextMessages(ctx context.Context, arg GetContextMessagesParams) ([]GetContextMessagesRow, error) {
	rows, err := q.db.Query(ctx, getContextMessages,
		arg.RoomID,
		arg.Column2,
		arg.Limit,
		arg.Limit_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContextMessagesRow{}
	for rows.Next() {
		var i GetContextMessagesRow
		if err := rows.Scan(
			&i.MessageID,
			&i.SenderContactID,
			&i.EventID,
			&i.EventDatetime,
			&i.Body,
			&i.FormattedBody,
			&i.MessageType,
			&i.MessageClassification,
			&i.TranscriptionData,
			&i.BookmarkID,
			&i.BookmarkUrl,
			&i.BookmarkTitle,
			&i.BookmarkSummary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessage = `-- name: GetMessage :one
SELECT
    m.message_id,
    m.sender_contact_id,
    m.room_id,
    m.event_id,
    m.event_datetime,
    m.body,
    m.formatted_body,
    m.message_type,
    c.name AS sender_name,
    c.email AS sender_email
FROM messages m
LEFT JOIN contacts c ON m.sender_contact_id = c.contact_id
WHERE m.message_id = $1
`

type GetMessageRow struct {
	MessageID       uuid.UUID        `json:"message_id"`
	SenderContactID uuid.UUID        `json:"sender_contact_id"`
	RoomID          uuid.UUID        `json:"room_id"`
	EventID         string           `json:"event_id"`
	EventDatetime   pgtype.Timestamp `json:"event_datetime"`
	Body            *string          `json:"body"`
	FormattedBody   *string          `json:"formatted_body"`
	MessageType     *string          `json:"message_type"`
	SenderName      *string          `json:"sender_name"`
	SenderEmail     *string          `json:"sender_email"`
}

func (q *Queries) GetMessage(ctx context.Context, messageID uuid.UUID) (GetMessageRow, error) {
	row := q.db.QueryRow(ctx, getMessage, messageID)
	var i GetMessageRow
	err := row.Scan(
		&i.MessageID,
		&i.SenderContactID,
		&i.RoomID,
		&i.EventID,
		&i.EventDatetime,
		&i.Body,
		&i.FormattedBody,
		&i.MessageType,
		&i.SenderName,
		&i.SenderEmail,
	)
	return i, err
}

const getMessageContacts = `-- name: GetMessageContacts :many
SELECT DISTINCT
    c.contact_id,
    c.name,
    c.email
FROM contacts c
WHERE c.contact_id = ANY($1::uuid[])
`

type GetMessageContactsRow struct {
	ContactID uuid.UUID `json:"contact_id"`
	Name      string    `json:"name"`
	Email     *string   `json:"email"`
}

func (q *Queries) GetMessageContacts(ctx context.Context, dollar_1 []uuid.UUID) ([]GetMessageContactsRow, error) {
	rows, err := q.db.Query(ctx, getMessageContacts, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessageContactsRow{}
	for rows.Next() {
		var i GetMessageContactsRow
		if err := rows.Scan(&i.ContactID, &i.Name, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageTextRepresentations = `-- name: GetMessageTextRepresentations :many
SELECT
    id,
    message_id,
    text_content,
    source_type,
    created_at
FROM message_text_representation
WHERE message_id = $1
`

type GetMessageTextRepresentationsRow struct {
	ID          uuid.UUID        `json:"id"`
	MessageID   uuid.UUID        `json:"message_id"`
	TextContent string           `json:"text_content"`
	SourceType  string           `json:"source_type"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetMessageTextRepresentations(ctx context.Context, messageID uuid.UUID) ([]GetMessageTextRepresentationsRow, error) {
	rows, err := q.db.Query(ctx, getMessageTextRepresentations, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessageTextRepresentationsRow{}
	for rows.Next() {
		var i GetMessageTextRepresentationsRow
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.TextContent,
			&i.SourceType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomMessages = `-- name: GetRoomMessages :many
SELECT
    m.message_id,
    m.sender_contact_id,
    m.event_id,
    m.event_datetime,
    m.body,
    m.formatted_body,
    m.message_type,
    m.message_classification,
    o.data AS transcription_data,
    b.bookmark_id,
    b.url AS bookmark_url,
    bt.title AS bookmark_title,
    bcr.content AS bookmark_summary
FROM messages m
LEFT JOIN observations o ON o.ref = m.message_id AND o.type = 'transcription'
LEFT JOIN bookmark_sources bs ON bs.source_uri = m.event_id
LEFT JOIN bookmarks b ON b.bookmark_id = bs.bookmark_id
LEFT JOIN bookmark_titles bt ON bt.bookmark_id = b.bookmark_id
LEFT JOIN bookmark_content_references bcr ON bcr.bookmark_id = b.bookmark_id
    AND bcr.strategy = 'summary-reader'
WHERE m.room_id = $1
    AND CASE
        WHEN $4::timestamp IS NOT NULL THEN
            m.event_datetime < $4::timestamp
        ELSE TRUE
    END
ORDER BY m.event_datetime DESC
LIMIT $2 OFFSET $3
`

type GetRoomMessagesParams struct {
	RoomID         uuid.UUID        `json:"room_id"`
	Limit          int32            `json:"limit"`
	Offset         int32            `json:"offset"`
	BeforeDatetime pgtype.Timestamp `json:"before_datetime"`
}

type GetRoomMessagesRow struct {
	MessageID             uuid.UUID        `json:"message_id"`
	SenderContactID       uuid.UUID        `json:"sender_contact_id"`
	EventID               string           `json:"event_id"`
	EventDatetime         pgtype.Timestamp `json:"event_datetime"`
	Body                  *string          `json:"body"`
	FormattedBody         *string          `json:"formatted_body"`
	MessageType           *string          `json:"message_type"`
	MessageClassification *string          `json:"message_classification"`
	TranscriptionData     []byte           `json:"transcription_data"`
	BookmarkID            pgtype.UUID      `json:"bookmark_id"`
	BookmarkUrl           *string          `json:"bookmark_url"`
	BookmarkTitle         *string          `json:"bookmark_title"`
	BookmarkSummary       *string          `json:"bookmark_summary"`
}

func (q *Queries) GetRoomMessages(ctx context.Context, arg GetRoomMessagesParams) ([]GetRoomMessagesRow, error) {
	rows, err := q.db.Query(ctx, getRoomMessages,
		arg.RoomID,
		arg.Limit,
		arg.Offset,
		arg.BeforeDatetime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRoomMessagesRow{}
	for rows.Next() {
		var i GetRoomMessagesRow
		if err := rows.Scan(
			&i.MessageID,
			&i.SenderContactID,
			&i.EventID,
			&i.EventDatetime,
			&i.Body,
			&i.FormattedBody,
			&i.MessageType,
			&i.MessageClassification,
			&i.TranscriptionData,
			&i.BookmarkID,
			&i.BookmarkUrl,
			&i.BookmarkTitle,
			&i.BookmarkSummary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMessages = `-- name: SearchMessages :many
SELECT
    m.message_id,
    m.sender_contact_id,
    m.room_id,
    m.event_id,
    m.event_datetime,
    m.body,
    m.formatted_body,
    m.message_type,
    mtr.text_content,
    ts_rank(mtr.search_vector, to_tsquery('english', $1)) AS rank
FROM messages m
INNER JOIN message_text_representation mtr ON m.message_id = mtr.message_id
WHERE mtr.search_vector @@ to_tsquery('english', $1)
ORDER BY rank DESC, m.event_datetime DESC
LIMIT $2 OFFSET $3
`

type SearchMessagesParams struct {
	ToTsquery string `json:"to_tsquery"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

type SearchMessagesRow struct {
	MessageID       uuid.UUID        `json:"message_id"`
	SenderContactID uuid.UUID        `json:"sender_contact_id"`
	RoomID          uuid.UUID        `json:"room_id"`
	EventID         string           `json:"event_id"`
	EventDatetime   pgtype.Timestamp `json:"event_datetime"`
	Body            *string          `json:"body"`
	FormattedBody   *string          `json:"formatted_body"`
	MessageType     *string          `json:"message_type"`
	TextContent     string           `json:"text_content"`
	Rank            float32          `json:"rank"`
}

func (q *Queries) SearchMessages(ctx context.Context, arg SearchMessagesParams) ([]SearchMessagesRow, error) {
	rows, err := q.db.Query(ctx, searchMessages, arg.ToTsquery, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchMessagesRow{}
	for rows.Next() {
		var i SearchMessagesRow
		if err := rows.Scan(
			&i.MessageID,
			&i.SenderContactID,
			&i.RoomID,
			&i.EventID,
			&i.EventDatetime,
			&i.Body,
			&i.FormattedBody,
			&i.MessageType,
			&i.TextContent,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRoomMessages = `-- name: SearchRoomMessages :many
SELECT
    m.message_id,
    m.sender_contact_id,
    m.event_id,
    m.event_datetime,
    m.body,
    m.formatted_body,
    m.message_type,
    m.message_classification,
    o.data AS transcription_data,
    b.bookmark_id,
    b.url AS bookmark_url,
    bt.title AS bookmark_title,
    bcr.content AS bookmark_summary
FROM messages m
LEFT JOIN observations o ON o.ref = m.message_id AND o.type = 'transcription'
LEFT JOIN bookmark_sources bs ON bs.source_uri = m.event_id
LEFT JOIN bookmarks b ON b.bookmark_id = bs.bookmark_id
LEFT JOIN bookmark_titles bt ON bt.bookmark_id = b.bookmark_id
LEFT JOIN bookmark_content_references bcr ON bcr.bookmark_id = b.bookmark_id
    AND bcr.strategy = 'summary-reader'
WHERE m.room_id = $1
    AND m.body ILIKE '%' || $2 || '%'
ORDER BY m.event_datetime DESC
LIMIT $3 OFFSET $4
`

type SearchRoomMessagesParams struct {
	RoomID  uuid.UUID `json:"room_id"`
	Column2 *string   `json:"column_2"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type SearchRoomMessagesRow struct {
	MessageID             uuid.UUID        `json:"message_id"`
	SenderContactID       uuid.UUID        `json:"sender_contact_id"`
	EventID               string           `json:"event_id"`
	EventDatetime         pgtype.Timestamp `json:"event_datetime"`
	Body                  *string          `json:"body"`
	FormattedBody         *string          `json:"formatted_body"`
	MessageType           *string          `json:"message_type"`
	MessageClassification *string          `json:"message_classification"`
	TranscriptionData     []byte           `json:"transcription_data"`
	BookmarkID            pgtype.UUID      `json:"bookmark_id"`
	BookmarkUrl           *string          `json:"bookmark_url"`
	BookmarkTitle         *string          `json:"bookmark_title"`
	BookmarkSummary       *string          `json:"bookmark_summary"`
}

func (q *Queries) SearchRoomMessages(ctx context.Context, arg SearchRoomMessagesParams) ([]SearchRoomMessagesRow, error) {
	rows, err := q.db.Query(ctx, searchRoomMessages,
		arg.RoomID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchRoomMessagesRow{}
	for rows.Next() {
		var i SearchRoomMessagesRow
		if err := rows.Scan(
			&i.MessageID,
			&i.SenderContactID,
			&i.EventID,
			&i.EventDatetime,
			&i.Body,
			&i.FormattedBody,
			&i.MessageType,
			&i.MessageClassification,
			&i.TranscriptionData,
			&i.BookmarkID,
			&i.BookmarkUrl,
			&i.BookmarkTitle,
			&i.BookmarkSummary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
