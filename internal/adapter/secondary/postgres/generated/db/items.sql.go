// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: items.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const countAllItems = `-- name: CountAllItems :one
SELECT COUNT(*) FROM items
`

func (q *Queries) CountAllItems(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllItems)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createItemRecord = `-- name: CreateItemRecord :one
INSERT INTO items (
    title,
    slug,
    contents,
    created,
    modified
) VALUES (
    $1, $2, $3,
    EXTRACT(epoch FROM CURRENT_TIMESTAMP),
    EXTRACT(epoch FROM CURRENT_TIMESTAMP)
) RETURNING id, title, slug, contents, created, modified
`

type CreateItemRecordParams struct {
	Title    *string `json:"title"`
	Slug     *string `json:"slug"`
	Contents *string `json:"contents"`
}

func (q *Queries) CreateItemRecord(ctx context.Context, arg CreateItemRecordParams) (Item, error) {
	row := q.db.QueryRow(ctx, createItemRecord, arg.Title, arg.Slug, arg.Contents)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Contents,
		&i.Created,
		&i.Modified,
	)
	return i, err
}

const createItemTagLinkage = `-- name: CreateItemTagLinkage :exec
INSERT INTO item_tags (item_id, tag_id)
VALUES ($1, $2)
`

type CreateItemTagLinkageParams struct {
	ItemID uuid.UUID `json:"item_id"`
	TagID  uuid.UUID `json:"tag_id"`
}

func (q *Queries) CreateItemTagLinkage(ctx context.Context, arg CreateItemTagLinkageParams) error {
	_, err := q.db.Exec(ctx, createItemTagLinkage, arg.ItemID, arg.TagID)
	return err
}

const deleteItemRecord = `-- name: DeleteItemRecord :exec
DELETE FROM items WHERE id = $1
`

func (q *Queries) DeleteItemRecord(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteItemRecord, id)
	return err
}

const deleteItemSemanticIndexRecord = `-- name: DeleteItemSemanticIndexRecord :exec
DELETE FROM item_semantic_index WHERE item_id = $1
`

func (q *Queries) DeleteItemSemanticIndexRecord(ctx context.Context, itemID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteItemSemanticIndexRecord, itemID)
	return err
}

const deleteItemTagsRelation = `-- name: DeleteItemTagsRelation :exec
DELETE FROM item_tags WHERE item_id = $1
`

func (q *Queries) DeleteItemTagsRelation(ctx context.Context, itemID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteItemTagsRelation, itemID)
	return err
}

const getItemByID = `-- name: GetItemByID :one
SELECT
    i.id,
    i.title,
    i.slug,
    i.contents,
    i.created,
    i.modified
FROM items i
WHERE i.id = $1
`

func (q *Queries) GetItemByID(ctx context.Context, id uuid.UUID) (Item, error) {
	row := q.db.QueryRow(ctx, getItemByID, id)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Contents,
		&i.Created,
		&i.Modified,
	)
	return i, err
}

const getItemTagByTagName = `-- name: GetItemTagByTagName :one
SELECT id, name, created, modified, last_activity
FROM tags
WHERE name = $1
LIMIT 1
`

func (q *Queries) GetItemTagByTagName(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRow(ctx, getItemTagByTagName, name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Created,
		&i.Modified,
		&i.LastActivity,
	)
	return i, err
}

const getItemTagsList = `-- name: GetItemTagsList :one
SELECT
    array_agg(DISTINCT t.name) FILTER (WHERE t.name IS NOT NULL) as tags
FROM items i
LEFT JOIN item_tags it ON i.id = it.item_id
LEFT JOIN tags t ON it.tag_id = t.id
WHERE i.id = $1
GROUP BY i.id
`

func (q *Queries) GetItemTagsList(ctx context.Context, id uuid.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, getItemTagsList, id)
	var tags interface{}
	err := row.Scan(&tags)
	return tags, err
}

const getItemWithTagsByID = `-- name: GetItemWithTagsByID :one
SELECT
    i.id,
    i.title,
    i.slug,
    i.contents,
    i.created,
    i.modified,
    array_agg(DISTINCT t.name) FILTER (WHERE t.name IS NOT NULL) as tags
FROM items i
LEFT JOIN item_tags it ON i.id = it.item_id
LEFT JOIN tags t ON it.tag_id = t.id
WHERE i.id = $1
GROUP BY i.id, i.title, i.slug, i.contents, i.created, i.modified
`

type GetItemWithTagsByIDRow struct {
	ID       uuid.UUID   `json:"id"`
	Title    *string     `json:"title"`
	Slug     *string     `json:"slug"`
	Contents *string     `json:"contents"`
	Created  *int64      `json:"created"`
	Modified *int64      `json:"modified"`
	Tags     interface{} `json:"tags"`
}

func (q *Queries) GetItemWithTagsByID(ctx context.Context, id uuid.UUID) (GetItemWithTagsByIDRow, error) {
	row := q.db.QueryRow(ctx, getItemWithTagsByID, id)
	var i GetItemWithTagsByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Contents,
		&i.Created,
		&i.Modified,
		&i.Tags,
	)
	return i, err
}

const listAllItems = `-- name: ListAllItems :many
SELECT
    i.id,
    i.title,
    i.created,
    i.modified,
    array_agg(DISTINCT t.name) FILTER (WHERE t.name IS NOT NULL) as tags
FROM items i
LEFT JOIN item_tags it ON i.id = it.item_id
LEFT JOIN tags t ON it.tag_id = t.id
GROUP BY i.id, i.title, i.created, i.modified
ORDER BY i.modified DESC
LIMIT $1 OFFSET $2
`

type ListAllItemsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAllItemsRow struct {
	ID       uuid.UUID   `json:"id"`
	Title    *string     `json:"title"`
	Created  *int64      `json:"created"`
	Modified *int64      `json:"modified"`
	Tags     interface{} `json:"tags"`
}

func (q *Queries) ListAllItems(ctx context.Context, arg ListAllItemsParams) ([]ListAllItemsRow, error) {
	rows, err := q.db.Query(ctx, listAllItems, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllItemsRow{}
	for rows.Next() {
		var i ListAllItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Created,
			&i.Modified,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSimilarItemsByEmbedding = `-- name: SearchSimilarItemsByEmbedding :many
SELECT
    i.id,
    i.title,
    i.created,
    i.modified,
    array_agg(DISTINCT t.name) FILTER (WHERE t.name IS NOT NULL) as tags
FROM items i
INNER JOIN item_semantic_index isi ON i.id = isi.item_id
LEFT JOIN item_tags it ON i.id = it.item_id
LEFT JOIN tags t ON it.tag_id = t.id
GROUP BY i.id, i.title, i.created, i.modified, isi.embedding
ORDER BY isi.embedding <=> $1::vector
LIMIT $2
`

type SearchSimilarItemsByEmbeddingParams struct {
	Column1 *pgvector.Vector `json:"column_1"`
	Limit   int32            `json:"limit"`
}

type SearchSimilarItemsByEmbeddingRow struct {
	ID       uuid.UUID   `json:"id"`
	Title    *string     `json:"title"`
	Created  *int64      `json:"created"`
	Modified *int64      `json:"modified"`
	Tags     interface{} `json:"tags"`
}

func (q *Queries) SearchSimilarItemsByEmbedding(ctx context.Context, arg SearchSimilarItemsByEmbeddingParams) ([]SearchSimilarItemsByEmbeddingRow, error) {
	rows, err := q.db.Query(ctx, searchSimilarItemsByEmbedding, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchSimilarItemsByEmbeddingRow{}
	for rows.Next() {
		var i SearchSimilarItemsByEmbeddingRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Created,
			&i.Modified,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateItemRecord = `-- name: UpdateItemRecord :exec
UPDATE items
SET
    title = $2,
    contents = $3,
    modified = EXTRACT(epoch FROM CURRENT_TIMESTAMP)
WHERE id = $1
`

type UpdateItemRecordParams struct {
	ID       uuid.UUID `json:"id"`
	Title    *string   `json:"title"`
	Contents *string   `json:"contents"`
}

func (q *Queries) UpdateItemRecord(ctx context.Context, arg UpdateItemRecordParams) error {
	_, err := q.db.Exec(ctx, updateItemRecord, arg.ID, arg.Title, arg.Contents)
	return err
}

const upsertItemTagRecord = `-- name: UpsertItemTagRecord :one
INSERT INTO tags (
    name,
    created,
    modified,
    last_activity
) VALUES (
    $1,
    EXTRACT(epoch FROM CURRENT_TIMESTAMP),
    EXTRACT(epoch FROM CURRENT_TIMESTAMP),
    $2
)
ON CONFLICT (name) DO UPDATE
SET
    last_activity = $2,
    modified = EXTRACT(epoch FROM CURRENT_TIMESTAMP)
RETURNING id, name, created, modified, last_activity
`

type UpsertItemTagRecordParams struct {
	Name         string `json:"name"`
	LastActivity *int64 `json:"last_activity"`
}

func (q *Queries) UpsertItemTagRecord(ctx context.Context, arg UpsertItemTagRecordParams) (Tag, error) {
	row := q.db.QueryRow(ctx, upsertItemTagRecord, arg.Name, arg.LastActivity)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Created,
		&i.Modified,
		&i.LastActivity,
	)
	return i, err
}
