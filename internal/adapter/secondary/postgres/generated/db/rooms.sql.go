// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: rooms.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countRooms = `-- name: CountRooms :one
SELECT COUNT(DISTINCT r.room_id)
FROM rooms r
WHERE
    CASE
        WHEN $1::text IS NOT NULL THEN
            (r.display_name ILIKE '%' || $1::text || '%' OR
             r.user_defined_name ILIKE '%' || $1::text || '%')
        ELSE TRUE
    END
`

func (q *Queries) CountRooms(ctx context.Context, searchText *string) (int64, error) {
	row := q.db.QueryRow(ctx, countRooms, searchText)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRoom = `-- name: GetRoom :one
SELECT
    r.room_id,
    r.display_name,
    r.user_defined_name,
    r.source_id,
    r.last_activity,
    MAX(m.created_at) AS last_message_time
FROM rooms r
LEFT JOIN messages m ON r.room_id = m.room_id
WHERE r.room_id = $1
GROUP BY r.room_id
`

type GetRoomRow struct {
	RoomID          uuid.UUID        `json:"room_id"`
	DisplayName     *string          `json:"display_name"`
	UserDefinedName *string          `json:"user_defined_name"`
	SourceID        string           `json:"source_id"`
	LastActivity    pgtype.Timestamp `json:"last_activity"`
	LastMessageTime interface{}      `json:"last_message_time"`
}

func (q *Queries) GetRoom(ctx context.Context, roomID uuid.UUID) (GetRoomRow, error) {
	row := q.db.QueryRow(ctx, getRoom, roomID)
	var i GetRoomRow
	err := row.Scan(
		&i.RoomID,
		&i.DisplayName,
		&i.UserDefinedName,
		&i.SourceID,
		&i.LastActivity,
		&i.LastMessageTime,
	)
	return i, err
}

const getRoomParticipants = `-- name: GetRoomParticipants :many
SELECT
    rp.room_id,
    rp.contact_id,
    rp.known_last_presence,
    rp.known_last_exit,
    c.name AS contact_name,
    c.email AS contact_email
FROM room_participants rp
INNER JOIN contacts c ON rp.contact_id = c.contact_id
WHERE rp.room_id = $1
`

type GetRoomParticipantsRow struct {
	RoomID            uuid.UUID        `json:"room_id"`
	ContactID         uuid.UUID        `json:"contact_id"`
	KnownLastPresence pgtype.Timestamp `json:"known_last_presence"`
	KnownLastExit     pgtype.Timestamp `json:"known_last_exit"`
	ContactName       string           `json:"contact_name"`
	ContactEmail      *string          `json:"contact_email"`
}

func (q *Queries) GetRoomParticipants(ctx context.Context, roomID uuid.UUID) ([]GetRoomParticipantsRow, error) {
	rows, err := q.db.Query(ctx, getRoomParticipants, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRoomParticipantsRow{}
	for rows.Next() {
		var i GetRoomParticipantsRow
		if err := rows.Scan(
			&i.RoomID,
			&i.ContactID,
			&i.KnownLastPresence,
			&i.KnownLastExit,
			&i.ContactName,
			&i.ContactEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomSessionsCount = `-- name: GetRoomSessionsCount :one
SELECT COUNT(session_id)::int
FROM sessions
WHERE room_id = $1
`

func (q *Queries) GetRoomSessionsCount(ctx context.Context, roomID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getRoomSessionsCount, roomID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const listRooms = `-- name: ListRooms :many
SELECT
    r.room_id,
    r.display_name,
    r.user_defined_name,
    r.last_activity,
    COUNT(DISTINCT rp.contact_id)::int AS participant_count,
    MAX(m.created_at) AS last_message_time
FROM rooms r
LEFT JOIN room_participants rp ON r.room_id = rp.room_id
LEFT JOIN messages m ON r.room_id = m.room_id
WHERE
    CASE
        WHEN $3::text IS NOT NULL THEN
            (r.display_name ILIKE '%' || $3::text || '%' OR
             r.user_defined_name ILIKE '%' || $3::text || '%')
        ELSE TRUE
    END
GROUP BY r.room_id
ORDER BY MAX(m.created_at) DESC NULLS LAST
LIMIT $1 OFFSET $2
`

type ListRoomsParams struct {
	Limit      int32   `json:"limit"`
	Offset     int32   `json:"offset"`
	SearchText *string `json:"search_text"`
}

type ListRoomsRow struct {
	RoomID           uuid.UUID        `json:"room_id"`
	DisplayName      *string          `json:"display_name"`
	UserDefinedName  *string          `json:"user_defined_name"`
	LastActivity     pgtype.Timestamp `json:"last_activity"`
	ParticipantCount int32            `json:"participant_count"`
	LastMessageTime  interface{}      `json:"last_message_time"`
}

func (q *Queries) ListRooms(ctx context.Context, arg ListRoomsParams) ([]ListRoomsRow, error) {
	rows, err := q.db.Query(ctx, listRooms, arg.Limit, arg.Offset, arg.SearchText)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRoomsRow{}
	for rows.Next() {
		var i ListRoomsRow
		if err := rows.Scan(
			&i.RoomID,
			&i.DisplayName,
			&i.UserDefinedName,
			&i.LastActivity,
			&i.ParticipantCount,
			&i.LastMessageTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRoomName = `-- name: UpdateRoomName :exec
UPDATE rooms
SET user_defined_name = $2
WHERE room_id = $1
`

type UpdateRoomNameParams struct {
	RoomID          uuid.UUID `json:"room_id"`
	UserDefinedName *string   `json:"user_defined_name"`
}

func (q *Queries) UpdateRoomName(ctx context.Context, arg UpdateRoomNameParams) error {
	_, err := q.db.Exec(ctx, updateRoomName, arg.RoomID, arg.UserDefinedName)
	return err
}
