// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: sessions.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const getContactsByIds = `-- name: GetContactsByIds :many
SELECT
    contact_id,
    name
FROM contacts
WHERE contact_id = ANY($1::uuid[])
`

type GetContactsByIdsRow struct {
	ContactID uuid.UUID `json:"contact_id"`
	Name      string    `json:"name"`
}

func (q *Queries) GetContactsByIds(ctx context.Context, dollar_1 []uuid.UUID) ([]GetContactsByIdsRow, error) {
	rows, err := q.db.Query(ctx, getContactsByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetContactsByIdsRow{}
	for rows.Next() {
		var i GetContactsByIdsRow
		if err := rows.Scan(&i.ContactID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionMessages = `-- name: GetSessionMessages :many
SELECT
    m.message_id,
    m.sender_contact_id,
    m.body,
    m.formatted_body,
    m.message_type,
    m.message_classification,
    m.event_datetime,
    o.data as transcription_data
FROM session_message sm
INNER JOIN messages m ON sm.message_id = m.message_id
LEFT JOIN observations o ON o.ref = m.message_id AND o.type = 'transcription'
WHERE sm.session_id = $1
ORDER BY m.event_datetime ASC
`

type GetSessionMessagesRow struct {
	MessageID             uuid.UUID        `json:"message_id"`
	SenderContactID       uuid.UUID        `json:"sender_contact_id"`
	Body                  *string          `json:"body"`
	FormattedBody         *string          `json:"formatted_body"`
	MessageType           *string          `json:"message_type"`
	MessageClassification *string          `json:"message_classification"`
	EventDatetime         pgtype.Timestamp `json:"event_datetime"`
	TranscriptionData     []byte           `json:"transcription_data"`
}

func (q *Queries) GetSessionMessages(ctx context.Context, sessionID uuid.UUID) ([]GetSessionMessagesRow, error) {
	rows, err := q.db.Query(ctx, getSessionMessages, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionMessagesRow{}
	for rows.Next() {
		var i GetSessionMessagesRow
		if err := rows.Scan(
			&i.MessageID,
			&i.SenderContactID,
			&i.Body,
			&i.FormattedBody,
			&i.MessageType,
			&i.MessageClassification,
			&i.EventDatetime,
			&i.TranscriptionData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionParticipantActivity = `-- name: GetSessionParticipantActivity :many
SELECT
    m.sender_contact_id,
    ct.name as sender_name,
    s.session_id,
    s.first_date_time,
    COUNT(m.message_id) as message_count
FROM messages m
INNER JOIN session_message sm ON m.message_id = sm.message_id
INNER JOIN sessions s ON sm.session_id = s.session_id
INNER JOIN contacts ct ON m.sender_contact_id = ct.contact_id
WHERE s.room_id = $1
GROUP BY m.sender_contact_id, ct.name, s.session_id, s.first_date_time
ORDER BY s.first_date_time ASC
`

type GetSessionParticipantActivityRow struct {
	SenderContactID uuid.UUID        `json:"sender_contact_id"`
	SenderName      string           `json:"sender_name"`
	SessionID       uuid.UUID        `json:"session_id"`
	FirstDateTime   pgtype.Timestamp `json:"first_date_time"`
	MessageCount    int64            `json:"message_count"`
}

func (q *Queries) GetSessionParticipantActivity(ctx context.Context, roomID uuid.UUID) ([]GetSessionParticipantActivityRow, error) {
	rows, err := q.db.Query(ctx, getSessionParticipantActivity, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionParticipantActivityRow{}
	for rows.Next() {
		var i GetSessionParticipantActivityRow
		if err := rows.Scan(
			&i.SenderContactID,
			&i.SenderName,
			&i.SessionID,
			&i.FirstDateTime,
			&i.MessageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionSummaries = `-- name: GetSessionSummaries :many
SELECT
    s.session_id,
    s.first_date_time,
    s.last_date_time,
    ss.summary
FROM sessions s
LEFT JOIN session_summaries ss ON s.session_id = ss.session_id
WHERE s.room_id = $1
ORDER BY s.first_date_time DESC
`

type GetSessionSummariesRow struct {
	SessionID     uuid.UUID        `json:"session_id"`
	FirstDateTime pgtype.Timestamp `json:"first_date_time"`
	LastDateTime  pgtype.Timestamp `json:"last_date_time"`
	Summary       *string          `json:"summary"`
}

func (q *Queries) GetSessionSummaries(ctx context.Context, roomID uuid.UUID) ([]GetSessionSummariesRow, error) {
	rows, err := q.db.Query(ctx, getSessionSummaries, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionSummariesRow{}
	for rows.Next() {
		var i GetSessionSummariesRow
		if err := rows.Scan(
			&i.SessionID,
			&i.FirstDateTime,
			&i.LastDateTime,
			&i.Summary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionsForRoom = `-- name: GetSessionsForRoom :many
SELECT
    s.session_id,
    s.first_date_time,
    s.last_date_time,
    COUNT(sm.message_id) as message_count
FROM sessions s
LEFT JOIN session_message sm ON s.session_id = sm.session_id
WHERE s.room_id = $1
GROUP BY s.session_id, s.first_date_time, s.last_date_time
ORDER BY s.first_date_time ASC
`

type GetSessionsForRoomRow struct {
	SessionID     uuid.UUID        `json:"session_id"`
	FirstDateTime pgtype.Timestamp `json:"first_date_time"`
	LastDateTime  pgtype.Timestamp `json:"last_date_time"`
	MessageCount  int64            `json:"message_count"`
}

func (q *Queries) GetSessionsForRoom(ctx context.Context, roomID uuid.UUID) ([]GetSessionsForRoomRow, error) {
	rows, err := q.db.Query(ctx, getSessionsForRoom, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSessionsForRoomRow{}
	for rows.Next() {
		var i GetSessionsForRoomRow
		if err := rows.Scan(
			&i.SessionID,
			&i.FirstDateTime,
			&i.LastDateTime,
			&i.MessageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchContactSessionSummaries = `-- name: SearchContactSessionSummaries :many
SELECT
    s.session_id,
    ss.summary,
    s.first_date_time,
    s.last_date_time,
    s.room_id
FROM session_summaries ss
LEFT JOIN sessions s ON ss.session_id = s.session_id
LEFT JOIN room_participants rp ON rp.room_id = s.room_id
WHERE rp.contact_id = $1
  AND ss.summary ILIKE $2
ORDER BY s.last_date_time DESC
`

type SearchContactSessionSummariesParams struct {
	ContactID uuid.UUID `json:"contact_id"`
	Summary   *string   `json:"summary"`
}

type SearchContactSessionSummariesRow struct {
	SessionID     pgtype.UUID      `json:"session_id"`
	Summary       *string          `json:"summary"`
	FirstDateTime pgtype.Timestamp `json:"first_date_time"`
	LastDateTime  pgtype.Timestamp `json:"last_date_time"`
	RoomID        pgtype.UUID      `json:"room_id"`
}

func (q *Queries) SearchContactSessionSummaries(ctx context.Context, arg SearchContactSessionSummariesParams) ([]SearchContactSessionSummariesRow, error) {
	rows, err := q.db.Query(ctx, searchContactSessionSummaries, arg.ContactID, arg.Summary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchContactSessionSummariesRow{}
	for rows.Next() {
		var i SearchContactSessionSummariesRow
		if err := rows.Scan(
			&i.SessionID,
			&i.Summary,
			&i.FirstDateTime,
			&i.LastDateTime,
			&i.RoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSessionsWithEmbeddings = `-- name: SearchSessionsWithEmbeddings :many
SELECT
    s.session_id,
    s.room_id,
    s.first_date_time,
    s.last_date_time,
    ss.summary,
    r.display_name,
    r.user_defined_name,
    1 - (ss.embedding <=> $1::vector) as similarity
FROM session_summaries ss
JOIN sessions s ON ss.session_id = s.session_id
JOIN rooms r ON s.room_id = r.room_id
WHERE ss.summary <> '' AND ss.summary IS NOT NULL
ORDER BY similarity DESC
LIMIT $2
`

type SearchSessionsWithEmbeddingsParams struct {
	Column1 *pgvector.Vector `json:"column_1"`
	Limit   int32            `json:"limit"`
}

type SearchSessionsWithEmbeddingsRow struct {
	SessionID       uuid.UUID        `json:"session_id"`
	RoomID          uuid.UUID        `json:"room_id"`
	FirstDateTime   pgtype.Timestamp `json:"first_date_time"`
	LastDateTime    pgtype.Timestamp `json:"last_date_time"`
	Summary         *string          `json:"summary"`
	DisplayName     *string          `json:"display_name"`
	UserDefinedName *string          `json:"user_defined_name"`
	Similarity      int32            `json:"similarity"`
}

func (q *Queries) SearchSessionsWithEmbeddings(ctx context.Context, arg SearchSessionsWithEmbeddingsParams) ([]SearchSessionsWithEmbeddingsRow, error) {
	rows, err := q.db.Query(ctx, searchSessionsWithEmbeddings, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchSessionsWithEmbeddingsRow{}
	for rows.Next() {
		var i SearchSessionsWithEmbeddingsRow
		if err := rows.Scan(
			&i.SessionID,
			&i.RoomID,
			&i.FirstDateTime,
			&i.LastDateTime,
			&i.Summary,
			&i.DisplayName,
			&i.UserDefinedName,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSessionsWithText = `-- name: SearchSessionsWithText :many
SELECT
    s.session_id,
    s.room_id,
    s.first_date_time,
    s.last_date_time,
    ss.summary,
    r.display_name,
    r.user_defined_name
FROM sessions s
LEFT JOIN session_summaries ss ON s.session_id = ss.session_id
LEFT JOIN rooms r ON s.room_id = r.room_id
WHERE ss.summary ILIKE $1
ORDER BY s.last_date_time DESC
LIMIT $2
`

type SearchSessionsWithTextParams struct {
	Summary *string `json:"summary"`
	Limit   int32   `json:"limit"`
}

type SearchSessionsWithTextRow struct {
	SessionID       uuid.UUID        `json:"session_id"`
	RoomID          uuid.UUID        `json:"room_id"`
	FirstDateTime   pgtype.Timestamp `json:"first_date_time"`
	LastDateTime    pgtype.Timestamp `json:"last_date_time"`
	Summary         *string          `json:"summary"`
	DisplayName     *string          `json:"display_name"`
	UserDefinedName *string          `json:"user_defined_name"`
}

func (q *Queries) SearchSessionsWithText(ctx context.Context, arg SearchSessionsWithTextParams) ([]SearchSessionsWithTextRow, error) {
	rows, err := q.db.Query(ctx, searchSessionsWithText, arg.Summary, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchSessionsWithTextRow{}
	for rows.Next() {
		var i SearchSessionsWithTextRow
		if err := rows.Scan(
			&i.SessionID,
			&i.RoomID,
			&i.FirstDateTime,
			&i.LastDateTime,
			&i.Summary,
			&i.DisplayName,
			&i.UserDefinedName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
