// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tags.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const countItemsByTagID = `-- name: CountItemsByTagID :one
SELECT COUNT(DISTINCT i.id)
FROM items i
INNER JOIN item_tags it ON i.id = it.item_id
WHERE it.tag_id = $1
`

func (q *Queries) CountItemsByTagID(ctx context.Context, tagID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countItemsByTagID, tagID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createItemTagRelationRecord = `-- name: CreateItemTagRelationRecord :exec
INSERT INTO item_tags (item_id, tag_id)
VALUES ($1, $2)
ON CONFLICT (item_id, tag_id) DO NOTHING
`

type CreateItemTagRelationRecordParams struct {
	ItemID uuid.UUID `json:"item_id"`
	TagID  uuid.UUID `json:"tag_id"`
}

func (q *Queries) CreateItemTagRelationRecord(ctx context.Context, arg CreateItemTagRelationRecordParams) error {
	_, err := q.db.Exec(ctx, createItemTagRelationRecord, arg.ItemID, arg.TagID)
	return err
}

const deleteAllTagRelationsRecord = `-- name: DeleteAllTagRelationsRecord :exec
DELETE FROM item_tags WHERE tag_id = $1
`

func (q *Queries) DeleteAllTagRelationsRecord(ctx context.Context, tagID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllTagRelationsRecord, tagID)
	return err
}

const deleteItemTagRelationRecord = `-- name: DeleteItemTagRelationRecord :exec
DELETE FROM item_tags
WHERE item_id = $1 AND tag_id = $2
`

type DeleteItemTagRelationRecordParams struct {
	ItemID uuid.UUID `json:"item_id"`
	TagID  uuid.UUID `json:"tag_id"`
}

func (q *Queries) DeleteItemTagRelationRecord(ctx context.Context, arg DeleteItemTagRelationRecordParams) error {
	_, err := q.db.Exec(ctx, deleteItemTagRelationRecord, arg.ItemID, arg.TagID)
	return err
}

const deleteTagRecord = `-- name: DeleteTagRecord :exec
DELETE FROM tags WHERE id = $1
`

func (q *Queries) DeleteTagRecord(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTagRecord, id)
	return err
}

const getItemsByTagID = `-- name: GetItemsByTagID :many
SELECT
    i.id,
    i.title,
    i.created,
    i.modified,
    array_agg(DISTINCT t.name) FILTER (WHERE t.name IS NOT NULL) as tags
FROM items i
INNER JOIN item_tags it ON i.id = it.item_id
LEFT JOIN item_tags it2 ON i.id = it2.item_id
LEFT JOIN tags t ON it2.tag_id = t.id
WHERE it.tag_id = $1
GROUP BY i.id, i.title, i.created, i.modified
ORDER BY i.modified DESC
LIMIT $2 OFFSET $3
`

type GetItemsByTagIDParams struct {
	TagID  uuid.UUID `json:"tag_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type GetItemsByTagIDRow struct {
	ID       uuid.UUID   `json:"id"`
	Title    *string     `json:"title"`
	Created  *int64      `json:"created"`
	Modified *int64      `json:"modified"`
	Tags     interface{} `json:"tags"`
}

func (q *Queries) GetItemsByTagID(ctx context.Context, arg GetItemsByTagIDParams) ([]GetItemsByTagIDRow, error) {
	rows, err := q.db.Query(ctx, getItemsByTagID, arg.TagID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetItemsByTagIDRow{}
	for rows.Next() {
		var i GetItemsByTagIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Created,
			&i.Modified,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagByName = `-- name: GetTagByName :one
SELECT id, name, created, modified, last_activity
FROM tags
WHERE name = $1
LIMIT 1
`

func (q *Queries) GetTagByName(ctx context.Context, name string) (Tag, error) {
	row := q.db.QueryRow(ctx, getTagByName, name)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Created,
		&i.Modified,
		&i.LastActivity,
	)
	return i, err
}

const listAllTagsRecords = `-- name: ListAllTagsRecords :many
SELECT id, name, created, modified, last_activity
FROM tags
ORDER BY name ASC
`

func (q *Queries) ListAllTagsRecords(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.Query(ctx, listAllTagsRecords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Modified,
			&i.LastActivity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllTagsWithUsageRecords = `-- name: ListAllTagsWithUsageRecords :many
SELECT
    t.id,
    t.name,
    t.created,
    t.modified,
    t.last_activity,
    COUNT(it.item_id) as usage_count
FROM tags t
LEFT JOIN item_tags it ON t.id = it.tag_id
GROUP BY t.id, t.name, t.created, t.modified, t.last_activity
ORDER BY usage_count DESC, t.name ASC
`

type ListAllTagsWithUsageRecordsRow struct {
	ID           uuid.UUID `json:"id"`
	Name         string    `json:"name"`
	Created      *int64    `json:"created"`
	Modified     *int64    `json:"modified"`
	LastActivity *int64    `json:"last_activity"`
	UsageCount   int64     `json:"usage_count"`
}

func (q *Queries) ListAllTagsWithUsageRecords(ctx context.Context) ([]ListAllTagsWithUsageRecordsRow, error) {
	rows, err := q.db.Query(ctx, listAllTagsWithUsageRecords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllTagsWithUsageRecordsRow{}
	for rows.Next() {
		var i ListAllTagsWithUsageRecordsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Created,
			&i.Modified,
			&i.LastActivity,
			&i.UsageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertTagRecord = `-- name: UpsertTagRecord :one
INSERT INTO tags (
    name,
    created,
    modified,
    last_activity
) VALUES (
    $1,
    $2,
    $2,
    $2
)
ON CONFLICT (name) DO UPDATE SET
    modified = $2,
    last_activity = $2
RETURNING id, name, created, modified, last_activity
`

type UpsertTagRecordParams struct {
	Name    string `json:"name"`
	Created *int64 `json:"created"`
}

func (q *Queries) UpsertTagRecord(ctx context.Context, arg UpsertTagRecordParams) (Tag, error) {
	row := q.db.QueryRow(ctx, upsertTagRecord, arg.Name, arg.Created)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Created,
		&i.Modified,
		&i.LastActivity,
	)
	return i, err
}
