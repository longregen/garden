// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: search.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const getSimilarQuestions = `-- name: GetSimilarQuestions :many
WITH similar_qa AS (
    SELECT
        bcr.content as question,
        bcr.bookmark_id,
        bcr.strategy,
        1 - (bcr.embedding <=> $1::vector) as similarity
    FROM bookmark_content_references as bcr
    WHERE bcr.strategy = 'qa-v2-passage'
    ORDER BY similarity DESC
    LIMIT $2::int
)
SELECT
    b.bookmark_id,
    COALESCE(bt.title, 'Untitled Bookmark') as title,
    b.url,
    COALESCE(reader.processed_content, '') as summary,
    sqa.question,
    sqa.similarity,
    sqa.strategy
FROM similar_qa sqa
INNER JOIN bookmarks b ON sqa.bookmark_id = b.bookmark_id
LEFT JOIN bookmark_titles bt ON b.bookmark_id = bt.bookmark_id
LEFT JOIN processed_contents reader ON b.bookmark_id = reader.bookmark_id AND reader.strategy_used = 'reader'
ORDER BY sqa.similarity DESC
`

type GetSimilarQuestionsParams struct {
	Embedding   *pgvector.Vector `json:"embedding"`
	SearchLimit int32            `json:"search_limit"`
}

type GetSimilarQuestionsRow struct {
	BookmarkID uuid.UUID `json:"bookmark_id"`
	Title      string    `json:"title"`
	Url        string    `json:"url"`
	Summary    string    `json:"summary"`
	Question   *string   `json:"question"`
	Similarity int32     `json:"similarity"`
	Strategy   *string   `json:"strategy"`
}

func (q *Queries) GetSimilarQuestions(ctx context.Context, arg GetSimilarQuestionsParams) ([]GetSimilarQuestionsRow, error) {
	rows, err := q.db.Query(ctx, getSimilarQuestions, arg.Embedding, arg.SearchLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSimilarQuestionsRow{}
	for rows.Next() {
		var i GetSimilarQuestionsRow
		if err := rows.Scan(
			&i.BookmarkID,
			&i.Title,
			&i.Url,
			&i.Summary,
			&i.Question,
			&i.Similarity,
			&i.Strategy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAll = `-- name: SearchAll :many
WITH search_union AS (
    -- Contacts
    SELECT
        'contact'::text as item_type,
        contact_id::text as item_id,
        COALESCE(name, '') as item_title,
        COALESCE(last_update, '1970-01-01'::timestamp) as last_activity
    FROM contacts
    WHERE name ILIKE '%' || $1::text || '%'

    UNION ALL

    -- Rooms (conversations)
    SELECT
        'conversation'::text as item_type,
        room_id::text as item_id,
        COALESCE(user_defined_name, display_name, '') as item_title,
        COALESCE(last_activity, '1970-01-01'::timestamp) as last_activity
    FROM rooms
    WHERE COALESCE(user_defined_name, display_name) ILIKE '%' || $1::text || '%'

    UNION ALL

    -- Bookmarks
    SELECT
        'bookmark'::text as item_type,
        bt.bookmark_id::text as item_id,
        COALESCE(bt.title, '') as item_title,
        COALESCE(b.creation_date, '1970-01-01'::timestamp) as last_activity
    FROM bookmark_titles bt
    LEFT JOIN bookmarks b ON bt.bookmark_id = b.bookmark_id
    WHERE bt.title ILIKE '%' || $1::text || '%'

    UNION ALL

    -- Browser history
    SELECT
        'history'::text as item_type,
        id::text as item_id,
        COALESCE(title, '') as item_title,
        COALESCE(visit_date, '1970-01-01'::timestamp) as last_activity
    FROM browser_history
    WHERE title ILIKE '%' || $1::text || '%'

    UNION ALL

    -- Items (notes)
    SELECT
        'note'::text as item_type,
        id::text as item_id,
        COALESCE(title, '') as item_title,
        COALESCE(to_timestamp(modified)::timestamp, '1970-01-01'::timestamp) as last_activity
    FROM items
    WHERE title ILIKE '%' || $1::text || '%'
)
SELECT
    item_type,
    item_id,
    item_title,
    last_activity,
    (
        -- Exact match weight
        CASE
            WHEN lower(LEFT(item_title, 255)) = lower(LEFT($1::text, 255))
            THEN $2::float
            ELSE 0
        END
    )
    +
    (
        -- Similarity weight using pg_trgm
        similarity(lower(LEFT(item_title, 255)), lower(LEFT($1::text, 255))) * $3::float
    )
    +
    (
        -- Recency weight
        CASE
            WHEN last_activity >= now() - interval '7 days'
                THEN $4::float
            WHEN last_activity >= now() - interval '30 days'
                THEN $4::float / 2.0
            ELSE 0
        END
    ) as search_score
FROM search_union
ORDER BY search_score DESC
LIMIT $5::int
`

type SearchAllParams struct {
	Query            string  `json:"query"`
	ExactMatchWeight float64 `json:"exact_match_weight"`
	SimilarityWeight float64 `json:"similarity_weight"`
	RecencyWeight    float64 `json:"recency_weight"`
	ResultLimit      int32   `json:"result_limit"`
}

type SearchAllRow struct {
	ItemType     string           `json:"item_type"`
	ItemID       string           `json:"item_id"`
	ItemTitle    string           `json:"item_title"`
	LastActivity pgtype.Timestamp `json:"last_activity"`
	SearchScore  int32            `json:"search_score"`
}

func (q *Queries) SearchAll(ctx context.Context, arg SearchAllParams) ([]SearchAllRow, error) {
	rows, err := q.db.Query(ctx, searchAll,
		arg.Query,
		arg.ExactMatchWeight,
		arg.SimilarityWeight,
		arg.RecencyWeight,
		arg.ResultLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchAllRow{}
	for rows.Next() {
		var i SearchAllRow
		if err := rows.Scan(
			&i.ItemType,
			&i.ItemID,
			&i.ItemTitle,
			&i.LastActivity,
			&i.SearchScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
