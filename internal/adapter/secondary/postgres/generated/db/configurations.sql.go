// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: configurations.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createConfiguration = `-- name: CreateConfiguration :one
INSERT INTO configurations (key, value, is_secret, updated_at)
VALUES ($1, $2, $3, $4)
RETURNING config_id, key, value, is_secret, created_at, updated_at
`

type CreateConfigurationParams struct {
	Key       string           `json:"key"`
	Value     string           `json:"value"`
	IsSecret  bool             `json:"is_secret"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) CreateConfiguration(ctx context.Context, arg CreateConfigurationParams) (Configuration, error) {
	row := q.db.QueryRow(ctx, createConfiguration,
		arg.Key,
		arg.Value,
		arg.IsSecret,
		arg.UpdatedAt,
	)
	var i Configuration
	err := row.Scan(
		&i.ConfigID,
		&i.Key,
		&i.Value,
		&i.IsSecret,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteConfiguration = `-- name: DeleteConfiguration :exec
DELETE FROM configurations
WHERE key = $1
`

func (q *Queries) DeleteConfiguration(ctx context.Context, key string) error {
	_, err := q.db.Exec(ctx, deleteConfiguration, key)
	return err
}

const getConfigurationByKey = `-- name: GetConfigurationByKey :one
SELECT config_id, key, value, is_secret, created_at, updated_at
FROM configurations
WHERE key = $1
`

func (q *Queries) GetConfigurationByKey(ctx context.Context, key string) (Configuration, error) {
	row := q.db.QueryRow(ctx, getConfigurationByKey, key)
	var i Configuration
	err := row.Scan(
		&i.ConfigID,
		&i.Key,
		&i.Value,
		&i.IsSecret,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConfigurationsByPrefix = `-- name: GetConfigurationsByPrefix :many
SELECT config_id, key, value, is_secret, created_at, updated_at
FROM configurations
WHERE
    key LIKE $1 || '%'
    AND ($2::boolean = true OR is_secret = false)
ORDER BY key
`

type GetConfigurationsByPrefixParams struct {
	Column1        *string `json:"column_1"`
	IncludeSecrets *bool   `json:"include_secrets"`
}

func (q *Queries) GetConfigurationsByPrefix(ctx context.Context, arg GetConfigurationsByPrefixParams) ([]Configuration, error) {
	rows, err := q.db.Query(ctx, getConfigurationsByPrefix, arg.Column1, arg.IncludeSecrets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Configuration{}
	for rows.Next() {
		var i Configuration
		if err := rows.Scan(
			&i.ConfigID,
			&i.Key,
			&i.Value,
			&i.IsSecret,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConfigurations = `-- name: ListConfigurations :many
SELECT config_id, key, value, is_secret, created_at, updated_at
FROM configurations
WHERE
    ($1::text IS NULL OR key LIKE $1::text || '%')
    AND ($2::boolean = true OR is_secret = false)
ORDER BY key
`

type ListConfigurationsParams struct {
	KeyPrefix      *string `json:"key_prefix"`
	IncludeSecrets *bool   `json:"include_secrets"`
}

func (q *Queries) ListConfigurations(ctx context.Context, arg ListConfigurationsParams) ([]Configuration, error) {
	rows, err := q.db.Query(ctx, listConfigurations, arg.KeyPrefix, arg.IncludeSecrets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Configuration{}
	for rows.Next() {
		var i Configuration
		if err := rows.Scan(
			&i.ConfigID,
			&i.Key,
			&i.Value,
			&i.IsSecret,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateConfiguration = `-- name: UpdateConfiguration :one
UPDATE configurations
SET value = $2, is_secret = $3, updated_at = $4
WHERE key = $1
RETURNING config_id, key, value, is_secret, created_at, updated_at
`

type UpdateConfigurationParams struct {
	Key       string           `json:"key"`
	Value     string           `json:"value"`
	IsSecret  bool             `json:"is_secret"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpdateConfiguration(ctx context.Context, arg UpdateConfigurationParams) (Configuration, error) {
	row := q.db.QueryRow(ctx, updateConfiguration,
		arg.Key,
		arg.Value,
		arg.IsSecret,
		arg.UpdatedAt,
	)
	var i Configuration
	err := row.Scan(
		&i.ConfigID,
		&i.Key,
		&i.Value,
		&i.IsSecret,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertConfiguration = `-- name: UpsertConfiguration :one
INSERT INTO configurations (key, value, is_secret, updated_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (key) DO UPDATE
SET value = EXCLUDED.value, is_secret = EXCLUDED.is_secret, updated_at = EXCLUDED.updated_at
RETURNING config_id, key, value, is_secret, created_at, updated_at
`

type UpsertConfigurationParams struct {
	Key       string           `json:"key"`
	Value     string           `json:"value"`
	IsSecret  bool             `json:"is_secret"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) UpsertConfiguration(ctx context.Context, arg UpsertConfigurationParams) (Configuration, error) {
	row := q.db.QueryRow(ctx, upsertConfiguration,
		arg.Key,
		arg.Value,
		arg.IsSecret,
		arg.UpdatedAt,
	)
	var i Configuration
	err := row.Scan(
		&i.ConfigID,
		&i.Key,
		&i.Value,
		&i.IsSecret,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
