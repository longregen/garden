// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: bookmarks.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const countBookmarks = `-- name: CountBookmarks :one
SELECT COUNT(DISTINCT b.bookmark_id)
FROM bookmarks b
LEFT JOIN bookmark_titles bt ON b.bookmark_id = bt.bookmark_id
LEFT JOIN bookmark_category bc ON b.bookmark_id = bc.bookmark_id
WHERE
    ($1::uuid IS NULL OR bc.category_id = $1)
    AND ($2::text IS NULL OR bt.title ILIKE '%' || $2 || '%')
    AND ($3::timestamp IS NULL OR b.creation_date >= $3)
    AND ($4::timestamp IS NULL OR b.creation_date <= $4)
`

type CountBookmarksParams struct {
	Column1 uuid.UUID        `json:"column_1"`
	Column2 string           `json:"column_2"`
	Column3 pgtype.Timestamp `json:"column_3"`
	Column4 pgtype.Timestamp `json:"column_4"`
}

func (q *Queries) CountBookmarks(ctx context.Context, arg CountBookmarksParams) (int64, error) {
	row := q.db.QueryRow(ctx, countBookmarks,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEmbeddingChunk = `-- name: CreateEmbeddingChunk :one
INSERT INTO bookmark_content_references (bookmark_id, content, strategy, embedding)
VALUES ($1, $2, $3, $4::vector)
RETURNING id
`

type CreateEmbeddingChunkParams struct {
	BookmarkID pgtype.UUID      `json:"bookmark_id"`
	Content    *string          `json:"content"`
	Strategy   *string          `json:"strategy"`
	Column4    *pgvector.Vector `json:"column_4"`
}

func (q *Queries) CreateEmbeddingChunk(ctx context.Context, arg CreateEmbeddingChunkParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createEmbeddingChunk,
		arg.BookmarkID,
		arg.Content,
		arg.Strategy,
		arg.Column4,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createObservation = `-- name: CreateObservation :exec
INSERT INTO observations (data, type, source, tags, ref)
VALUES ($1, $2, $3, $4, $5)
`

type CreateObservationParams struct {
	Data   []byte      `json:"data"`
	Type   *string     `json:"type"`
	Source *string     `json:"source"`
	Tags   *string     `json:"tags"`
	Ref    pgtype.UUID `json:"ref"`
}

func (q *Queries) CreateObservation(ctx context.Context, arg CreateObservationParams) error {
	_, err := q.db.Exec(ctx, createObservation,
		arg.Data,
		arg.Type,
		arg.Source,
		arg.Tags,
		arg.Ref,
	)
	return err
}

const deleteBookmarkQuestion = `-- name: DeleteBookmarkQuestion :exec
DELETE FROM bookmark_content_references
WHERE id = $1 AND bookmark_id = $2
`

type DeleteBookmarkQuestionParams struct {
	ID         uuid.UUID   `json:"id"`
	BookmarkID pgtype.UUID `json:"bookmark_id"`
}

func (q *Queries) DeleteBookmarkQuestion(ctx context.Context, arg DeleteBookmarkQuestionParams) error {
	_, err := q.db.Exec(ctx, deleteBookmarkQuestion, arg.ID, arg.BookmarkID)
	return err
}

const getBookmark = `-- name: GetBookmark :one
SELECT
    bookmark_id,
    url,
    creation_date
FROM bookmarks
WHERE bookmark_id = $1
`

func (q *Queries) GetBookmark(ctx context.Context, bookmarkID uuid.UUID) (Bookmark, error) {
	row := q.db.QueryRow(ctx, getBookmark, bookmarkID)
	var i Bookmark
	err := row.Scan(&i.BookmarkID, &i.Url, &i.CreationDate)
	return i, err
}

const getBookmarkDetails = `-- name: GetBookmarkDetails :one
SELECT
    b.bookmark_id,
    b.url,
    b.creation_date,
    c.name as category_name,
    bs.source_uri,
    bs.raw_source,
    bt.title,
    pc_lynx.processed_content as lynx_content,
    pc_reader.processed_content as reader_content,
    hr.status_code,
    hr.headers,
    hr.content as http_content,
    hr.fetch_date,
    bcr_summary.content as summary
FROM bookmarks b
LEFT JOIN bookmark_category bc ON b.bookmark_id = bc.bookmark_id
LEFT JOIN categories c ON bc.category_id = c.category_id
LEFT JOIN bookmark_sources bs ON b.bookmark_id = bs.bookmark_id
LEFT JOIN bookmark_titles bt ON b.bookmark_id = bt.bookmark_id
LEFT JOIN processed_contents pc_lynx ON b.bookmark_id = pc_lynx.bookmark_id AND pc_lynx.strategy_used = 'lynx'
LEFT JOIN processed_contents pc_reader ON b.bookmark_id = pc_reader.bookmark_id AND pc_reader.strategy_used = 'reader'
LEFT JOIN http_responses hr ON b.bookmark_id = hr.bookmark_id
LEFT JOIN bookmark_content_references bcr_summary ON b.bookmark_id = bcr_summary.bookmark_id AND bcr_summary.strategy = 'summary-reader'
WHERE b.bookmark_id = $1
`

type GetBookmarkDetailsRow struct {
	BookmarkID    uuid.UUID        `json:"bookmark_id"`
	Url           string           `json:"url"`
	CreationDate  pgtype.Timestamp `json:"creation_date"`
	CategoryName  *string          `json:"category_name"`
	SourceUri     *string          `json:"source_uri"`
	RawSource     []byte           `json:"raw_source"`
	Title         *string          `json:"title"`
	LynxContent   *string          `json:"lynx_content"`
	ReaderContent *string          `json:"reader_content"`
	StatusCode    *int32           `json:"status_code"`
	Headers       *string          `json:"headers"`
	HttpContent   []byte           `json:"http_content"`
	FetchDate     pgtype.Timestamp `json:"fetch_date"`
	Summary       *string          `json:"summary"`
}

func (q *Queries) GetBookmarkDetails(ctx context.Context, bookmarkID uuid.UUID) (GetBookmarkDetailsRow, error) {
	row := q.db.QueryRow(ctx, getBookmarkDetails, bookmarkID)
	var i GetBookmarkDetailsRow
	err := row.Scan(
		&i.BookmarkID,
		&i.Url,
		&i.CreationDate,
		&i.CategoryName,
		&i.SourceUri,
		&i.RawSource,
		&i.Title,
		&i.LynxContent,
		&i.ReaderContent,
		&i.StatusCode,
		&i.Headers,
		&i.HttpContent,
		&i.FetchDate,
		&i.Summary,
	)
	return i, err
}

const getBookmarkForQuestion = `-- name: GetBookmarkForQuestion :one
SELECT
    b.bookmark_id,
    bt.title,
    bcr.content as summary
FROM bookmarks b
LEFT JOIN bookmark_titles bt ON b.bookmark_id = bt.bookmark_id
LEFT JOIN bookmark_content_references bcr ON b.bookmark_id = bcr.bookmark_id AND bcr.strategy = 'summary-reader'
WHERE b.bookmark_id = $1
`

type GetBookmarkForQuestionRow struct {
	BookmarkID uuid.UUID `json:"bookmark_id"`
	Title      *string   `json:"title"`
	Summary    *string   `json:"summary"`
}

func (q *Queries) GetBookmarkForQuestion(ctx context.Context, bookmarkID uuid.UUID) (GetBookmarkForQuestionRow, error) {
	row := q.db.QueryRow(ctx, getBookmarkForQuestion, bookmarkID)
	var i GetBookmarkForQuestionRow
	err := row.Scan(&i.BookmarkID, &i.Title, &i.Summary)
	return i, err
}

const getBookmarkQuestions = `-- name: GetBookmarkQuestions :many
SELECT
    id,
    content
FROM bookmark_content_references
WHERE bookmark_id = $1 AND strategy = 'question-inference'
`

type GetBookmarkQuestionsRow struct {
	ID      uuid.UUID `json:"id"`
	Content *string   `json:"content"`
}

func (q *Queries) GetBookmarkQuestions(ctx context.Context, bookmarkID pgtype.UUID) ([]GetBookmarkQuestionsRow, error) {
	rows, err := q.db.Query(ctx, getBookmarkQuestions, bookmarkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBookmarkQuestionsRow{}
	for rows.Next() {
		var i GetBookmarkQuestionsRow
		if err := rows.Scan(&i.ID, &i.Content); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookmarkTitle = `-- name: GetBookmarkTitle :one
SELECT
    b.bookmark_id,
    b.url,
    b.creation_date,
    bt.title as existing_title,
    hr.content as raw_content,
    substring(pc.processed_content FROM '#([^\n]*)')::text as reader_title
FROM bookmarks b
LEFT JOIN bookmark_titles bt ON b.bookmark_id = bt.bookmark_id
LEFT JOIN http_responses hr ON b.bookmark_id = hr.bookmark_id
LEFT JOIN processed_contents pc ON b.bookmark_id = pc.bookmark_id AND pc.strategy_used = 'reader'
WHERE b.bookmark_id = $1
`

type GetBookmarkTitleRow struct {
	BookmarkID    uuid.UUID        `json:"bookmark_id"`
	Url           string           `json:"url"`
	CreationDate  pgtype.Timestamp `json:"creation_date"`
	ExistingTitle *string          `json:"existing_title"`
	RawContent    []byte           `json:"raw_content"`
	ReaderTitle   string           `json:"reader_title"`
}

func (q *Queries) GetBookmarkTitle(ctx context.Context, bookmarkID uuid.UUID) (GetBookmarkTitleRow, error) {
	row := q.db.QueryRow(ctx, getBookmarkTitle, bookmarkID)
	var i GetBookmarkTitleRow
	err := row.Scan(
		&i.BookmarkID,
		&i.Url,
		&i.CreationDate,
		&i.ExistingTitle,
		&i.RawContent,
		&i.ReaderTitle,
	)
	return i, err
}

const getLatestHttpResponse = `-- name: GetLatestHttpResponse :one
SELECT
    response_id,
    status_code,
    headers,
    content,
    fetch_date
FROM http_responses
WHERE bookmark_id = $1
ORDER BY fetch_date DESC
LIMIT 1
`

type GetLatestHttpResponseRow struct {
	ResponseID uuid.UUID        `json:"response_id"`
	StatusCode *int32           `json:"status_code"`
	Headers    *string          `json:"headers"`
	Content    []byte           `json:"content"`
	FetchDate  pgtype.Timestamp `json:"fetch_date"`
}

func (q *Queries) GetLatestHttpResponse(ctx context.Context, bookmarkID pgtype.UUID) (GetLatestHttpResponseRow, error) {
	row := q.db.QueryRow(ctx, getLatestHttpResponse, bookmarkID)
	var i GetLatestHttpResponseRow
	err := row.Scan(
		&i.ResponseID,
		&i.StatusCode,
		&i.Headers,
		&i.Content,
		&i.FetchDate,
	)
	return i, err
}

const getMissingHttpResponses = `-- name: GetMissingHttpResponses :many
SELECT
    b.bookmark_id,
    b.url,
    b.creation_date
FROM bookmarks b
LEFT JOIN http_responses hr ON b.bookmark_id = hr.bookmark_id
WHERE hr.response_id IS NULL
ORDER BY b.creation_date DESC
`

func (q *Queries) GetMissingHttpResponses(ctx context.Context) ([]Bookmark, error) {
	rows, err := q.db.Query(ctx, getMissingHttpResponses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(&i.BookmarkID, &i.Url, &i.CreationDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMissingReaderContent = `-- name: GetMissingReaderContent :many
SELECT
    b.bookmark_id,
    b.url,
    b.creation_date
FROM bookmarks b
LEFT JOIN processed_contents pc ON b.bookmark_id = pc.bookmark_id AND pc.strategy_used = 'reader'
WHERE pc.processed_content_id IS NULL
ORDER BY b.creation_date DESC
`

func (q *Queries) GetMissingReaderContent(ctx context.Context) ([]Bookmark, error) {
	rows, err := q.db.Query(ctx, getMissingReaderContent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bookmark{}
	for rows.Next() {
		var i Bookmark
		if err := rows.Scan(&i.BookmarkID, &i.Url, &i.CreationDate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProcessedContentByStrategy = `-- name: GetProcessedContentByStrategy :one
SELECT
    processed_content_id,
    processed_content
FROM processed_contents
WHERE bookmark_id = $1 AND strategy_used = $2
LIMIT 1
`

type GetProcessedContentByStrategyParams struct {
	BookmarkID   pgtype.UUID `json:"bookmark_id"`
	StrategyUsed *string     `json:"strategy_used"`
}

type GetProcessedContentByStrategyRow struct {
	ProcessedContentID uuid.UUID `json:"processed_content_id"`
	ProcessedContent   *string   `json:"processed_content"`
}

func (q *Queries) GetProcessedContentByStrategy(ctx context.Context, arg GetProcessedContentByStrategyParams) (GetProcessedContentByStrategyRow, error) {
	row := q.db.QueryRow(ctx, getProcessedContentByStrategy, arg.BookmarkID, arg.StrategyUsed)
	var i GetProcessedContentByStrategyRow
	err := row.Scan(&i.ProcessedContentID, &i.ProcessedContent)
	return i, err
}

const getRandomBookmark = `-- name: GetRandomBookmark :one
SELECT bookmark_id
FROM bookmarks
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomBookmark(ctx context.Context) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getRandomBookmark)
	var bookmark_id uuid.UUID
	err := row.Scan(&bookmark_id)
	return bookmark_id, err
}

const insertBookmarkTitle = `-- name: InsertBookmarkTitle :exec
INSERT INTO bookmark_titles (bookmark_id, title, source)
VALUES ($1, $2, $3)
`

type InsertBookmarkTitleParams struct {
	BookmarkID pgtype.UUID `json:"bookmark_id"`
	Title      *string     `json:"title"`
	Source     *string     `json:"source"`
}

func (q *Queries) InsertBookmarkTitle(ctx context.Context, arg InsertBookmarkTitleParams) error {
	_, err := q.db.Exec(ctx, insertBookmarkTitle, arg.BookmarkID, arg.Title, arg.Source)
	return err
}

const insertHttpResponse = `-- name: InsertHttpResponse :exec
INSERT INTO http_responses (bookmark_id, status_code, headers, content, fetch_date)
VALUES ($1, $2, $3, $4, $5)
`

type InsertHttpResponseParams struct {
	BookmarkID pgtype.UUID      `json:"bookmark_id"`
	StatusCode *int32           `json:"status_code"`
	Headers    *string          `json:"headers"`
	Content    []byte           `json:"content"`
	FetchDate  pgtype.Timestamp `json:"fetch_date"`
}

func (q *Queries) InsertHttpResponse(ctx context.Context, arg InsertHttpResponseParams) error {
	_, err := q.db.Exec(ctx, insertHttpResponse,
		arg.BookmarkID,
		arg.StatusCode,
		arg.Headers,
		arg.Content,
		arg.FetchDate,
	)
	return err
}

const insertProcessedContent = `-- name: InsertProcessedContent :exec
INSERT INTO processed_contents (bookmark_id, strategy_used, processed_content)
VALUES ($1, $2, $3)
`

type InsertProcessedContentParams struct {
	BookmarkID       pgtype.UUID `json:"bookmark_id"`
	StrategyUsed     *string     `json:"strategy_used"`
	ProcessedContent *string     `json:"processed_content"`
}

func (q *Queries) InsertProcessedContent(ctx context.Context, arg InsertProcessedContentParams) error {
	_, err := q.db.Exec(ctx, insertProcessedContent, arg.BookmarkID, arg.StrategyUsed, arg.ProcessedContent)
	return err
}

const listBookmarks = `-- name: ListBookmarks :many
SELECT DISTINCT
    b.bookmark_id,
    b.url,
    b.creation_date,
    bt.title
FROM bookmarks b
LEFT JOIN bookmark_titles bt ON b.bookmark_id = bt.bookmark_id
LEFT JOIN bookmark_category bc ON b.bookmark_id = bc.bookmark_id
WHERE
    ($1::uuid IS NULL OR bc.category_id = $1)
    AND ($2::text IS NULL OR bt.title ILIKE '%' || $2 || '%')
    AND ($3::timestamp IS NULL OR b.creation_date >= $3)
    AND ($4::timestamp IS NULL OR b.creation_date <= $4)
ORDER BY b.creation_date DESC
LIMIT $5
OFFSET $6
`

type ListBookmarksParams struct {
	Column1 uuid.UUID        `json:"column_1"`
	Column2 string           `json:"column_2"`
	Column3 pgtype.Timestamp `json:"column_3"`
	Column4 pgtype.Timestamp `json:"column_4"`
	Limit   int32            `json:"limit"`
	Offset  int32            `json:"offset"`
}

type ListBookmarksRow struct {
	BookmarkID   uuid.UUID        `json:"bookmark_id"`
	Url          string           `json:"url"`
	CreationDate pgtype.Timestamp `json:"creation_date"`
	Title        *string          `json:"title"`
}

func (q *Queries) ListBookmarks(ctx context.Context, arg ListBookmarksParams) ([]ListBookmarksRow, error) {
	rows, err := q.db.Query(ctx, listBookmarks,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBookmarksRow{}
	for rows.Next() {
		var i ListBookmarksRow
		if err := rows.Scan(
			&i.BookmarkID,
			&i.Url,
			&i.CreationDate,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchSimilarBookmarks = `-- name: SearchSimilarBookmarks :many
SELECT
    b.bookmark_id,
    b.url,
    b.creation_date,
    bt.title,
    bcr_summary.content as summary
FROM bookmarks b
INNER JOIN bookmark_content_references bcr ON b.bookmark_id = bcr.bookmark_id
INNER JOIN bookmark_titles bt ON b.bookmark_id = bt.bookmark_id
LEFT JOIN bookmark_content_references bcr_summary ON b.bookmark_id = bcr_summary.bookmark_id AND bcr_summary.strategy = 'summary-reader'
WHERE bcr.strategy = $1
ORDER BY bcr.embedding <=> $2::vector
LIMIT $3
`

type SearchSimilarBookmarksParams struct {
	Strategy *string          `json:"strategy"`
	Column2  *pgvector.Vector `json:"column_2"`
	Limit    int32            `json:"limit"`
}

type SearchSimilarBookmarksRow struct {
	BookmarkID   uuid.UUID        `json:"bookmark_id"`
	Url          string           `json:"url"`
	CreationDate pgtype.Timestamp `json:"creation_date"`
	Title        *string          `json:"title"`
	Summary      *string          `json:"summary"`
}

func (q *Queries) SearchSimilarBookmarks(ctx context.Context, arg SearchSimilarBookmarksParams) ([]SearchSimilarBookmarksRow, error) {
	rows, err := q.db.Query(ctx, searchSimilarBookmarks, arg.Strategy, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchSimilarBookmarksRow{}
	for rows.Next() {
		var i SearchSimilarBookmarksRow
		if err := rows.Scan(
			&i.BookmarkID,
			&i.Url,
			&i.CreationDate,
			&i.Title,
			&i.Summary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookmarkQuestion = `-- name: UpdateBookmarkQuestion :exec
UPDATE bookmark_content_references
SET
    content = $1,
    embedding = $2::vector
WHERE id = $3 AND bookmark_id = $4
`

type UpdateBookmarkQuestionParams struct {
	Content    *string          `json:"content"`
	Column2    *pgvector.Vector `json:"column_2"`
	ID         uuid.UUID        `json:"id"`
	BookmarkID pgtype.UUID      `json:"bookmark_id"`
}

func (q *Queries) UpdateBookmarkQuestion(ctx context.Context, arg UpdateBookmarkQuestionParams) error {
	_, err := q.db.Exec(ctx, updateBookmarkQuestion,
		arg.Content,
		arg.Column2,
		arg.ID,
		arg.BookmarkID,
	)
	return err
}
