// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: dashboard.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getBookmarkStats = `-- name: GetBookmarkStats :one
SELECT
    COUNT(*)::bigint as total,
    COUNT(*) FILTER (WHERE creation_date >= now() - interval '30 days')::bigint as recent_count,
    COUNT(*) FILTER (WHERE creation_date >= now() - interval '30 days')::bigint as current_period_count,
    COUNT(*) FILTER (WHERE creation_date >= now() - interval '60 days' AND creation_date < now() - interval '30 days')::bigint as previous_period_count
FROM bookmarks
`

type GetBookmarkStatsRow struct {
	Total               int64 `json:"total"`
	RecentCount         int64 `json:"recent_count"`
	CurrentPeriodCount  int64 `json:"current_period_count"`
	PreviousPeriodCount int64 `json:"previous_period_count"`
}

func (q *Queries) GetBookmarkStats(ctx context.Context) (GetBookmarkStatsRow, error) {
	row := q.db.QueryRow(ctx, getBookmarkStats)
	var i GetBookmarkStatsRow
	err := row.Scan(
		&i.Total,
		&i.RecentCount,
		&i.CurrentPeriodCount,
		&i.PreviousPeriodCount,
	)
	return i, err
}

const getContactStats = `-- name: GetContactStats :one
SELECT
    COUNT(*)::bigint as total,
    COUNT(*) FILTER (WHERE last_update >= now() - interval '30 days')::bigint as recently_active,
    COUNT(*) FILTER (WHERE last_update >= now() - interval '30 days')::bigint as current_period_count,
    COUNT(*) FILTER (WHERE last_update >= now() - interval '60 days' AND last_update < now() - interval '30 days')::bigint as previous_period_count
FROM contacts
`

type GetContactStatsRow struct {
	Total               int64 `json:"total"`
	RecentlyActive      int64 `json:"recently_active"`
	CurrentPeriodCount  int64 `json:"current_period_count"`
	PreviousPeriodCount int64 `json:"previous_period_count"`
}

func (q *Queries) GetContactStats(ctx context.Context) (GetContactStatsRow, error) {
	row := q.db.QueryRow(ctx, getContactStats)
	var i GetContactStatsRow
	err := row.Scan(
		&i.Total,
		&i.RecentlyActive,
		&i.CurrentPeriodCount,
		&i.PreviousPeriodCount,
	)
	return i, err
}

const getHistoryStats = `-- name: GetHistoryStats :one
SELECT
    COUNT(*)::bigint as total,
    COUNT(*) FILTER (WHERE visit_date >= now() - interval '30 days')::bigint as recent_count,
    COUNT(*) FILTER (WHERE visit_date >= now() - interval '30 days')::bigint as current_period_count,
    COUNT(*) FILTER (WHERE visit_date >= now() - interval '60 days' AND visit_date < now() - interval '30 days')::bigint as previous_period_count
FROM browser_history
`

type GetHistoryStatsRow struct {
	Total               int64 `json:"total"`
	RecentCount         int64 `json:"recent_count"`
	CurrentPeriodCount  int64 `json:"current_period_count"`
	PreviousPeriodCount int64 `json:"previous_period_count"`
}

func (q *Queries) GetHistoryStats(ctx context.Context) (GetHistoryStatsRow, error) {
	row := q.db.QueryRow(ctx, getHistoryStats)
	var i GetHistoryStatsRow
	err := row.Scan(
		&i.Total,
		&i.RecentCount,
		&i.CurrentPeriodCount,
		&i.PreviousPeriodCount,
	)
	return i, err
}

const getRecentBookmarks = `-- name: GetRecentBookmarks :many
SELECT
    b.bookmark_id::text as id,
    'Bookmark'::text as category,
    COALESCE(bt.title, '') as name,
    b.creation_date as date
FROM bookmarks b
LEFT JOIN bookmark_titles bt ON bt.bookmark_id = b.bookmark_id
WHERE b.creation_date >= now() - interval '30 days'
ORDER BY b.creation_date DESC
LIMIT 5
`

type GetRecentBookmarksRow struct {
	ID       string           `json:"id"`
	Category string           `json:"category"`
	Name     string           `json:"name"`
	Date     pgtype.Timestamp `json:"date"`
}

func (q *Queries) GetRecentBookmarks(ctx context.Context) ([]GetRecentBookmarksRow, error) {
	rows, err := q.db.Query(ctx, getRecentBookmarks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentBookmarksRow{}
	for rows.Next() {
		var i GetRecentBookmarksRow
		if err := rows.Scan(
			&i.ID,
			&i.Category,
			&i.Name,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentContacts = `-- name: GetRecentContacts :many
SELECT
    contact_id::text as id,
    'Contact'::text as category,
    name,
    last_update as date
FROM contacts
WHERE last_update >= now() - interval '30 days'
ORDER BY last_update DESC
LIMIT 5
`

type GetRecentContactsRow struct {
	ID       string           `json:"id"`
	Category string           `json:"category"`
	Name     string           `json:"name"`
	Date     pgtype.Timestamp `json:"date"`
}

func (q *Queries) GetRecentContacts(ctx context.Context) ([]GetRecentContactsRow, error) {
	rows, err := q.db.Query(ctx, getRecentContacts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentContactsRow{}
	for rows.Next() {
		var i GetRecentContactsRow
		if err := rows.Scan(
			&i.ID,
			&i.Category,
			&i.Name,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentHistory = `-- name: GetRecentHistory :many
SELECT
    browser_history.id::text as id,
    'History'::text as category,
    COALESCE(browser_history.title, '') as name,
    browser_history.visit_date as date
FROM browser_history
WHERE browser_history.visit_date >= now() - interval '30 days'
ORDER BY browser_history.visit_date DESC
LIMIT 5
`

type GetRecentHistoryRow struct {
	ID       string           `json:"id"`
	Category string           `json:"category"`
	Name     string           `json:"name"`
	Date     pgtype.Timestamp `json:"date"`
}

func (q *Queries) GetRecentHistory(ctx context.Context) ([]GetRecentHistoryRow, error) {
	rows, err := q.db.Query(ctx, getRecentHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentHistoryRow{}
	for rows.Next() {
		var i GetRecentHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Category,
			&i.Name,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentNotes = `-- name: GetRecentNotes :many
SELECT
    id::text as id,
    'Note'::text as category,
    COALESCE(title, '') as name,
    to_timestamp(modified) as date
FROM items
WHERE to_timestamp(modified) >= now() - interval '30 days'
ORDER BY to_timestamp(modified) DESC
LIMIT 5
`

type GetRecentNotesRow struct {
	ID       string      `json:"id"`
	Category string      `json:"category"`
	Name     string      `json:"name"`
	Date     interface{} `json:"date"`
}

func (q *Queries) GetRecentNotes(ctx context.Context) ([]GetRecentNotesRow, error) {
	rows, err := q.db.Query(ctx, getRecentNotes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentNotesRow{}
	for rows.Next() {
		var i GetRecentNotesRow
		if err := rows.Scan(
			&i.ID,
			&i.Category,
			&i.Name,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentSessions = `-- name: GetRecentSessions :many
SELECT
    s.session_id::text as id,
    'Session'::text as category,
    COALESCE(r.display_name, '') as name,
    s.last_date_time as date
FROM sessions s
LEFT JOIN rooms r ON r.room_id = s.room_id
WHERE s.last_date_time >= now() - interval '30 days'
ORDER BY s.last_date_time DESC
LIMIT 5
`

type GetRecentSessionsRow struct {
	ID       string           `json:"id"`
	Category string           `json:"category"`
	Name     string           `json:"name"`
	Date     pgtype.Timestamp `json:"date"`
}

func (q *Queries) GetRecentSessions(ctx context.Context) ([]GetRecentSessionsRow, error) {
	rows, err := q.db.Query(ctx, getRecentSessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentSessionsRow{}
	for rows.Next() {
		var i GetRecentSessionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Category,
			&i.Name,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionStats = `-- name: GetSessionStats :one
SELECT
    COUNT(*)::bigint as total,
    COUNT(*) FILTER (WHERE last_date_time >= now() - interval '30 days')::bigint as recent_count,
    COUNT(*) FILTER (WHERE last_date_time >= now() - interval '30 days')::bigint as current_period_count,
    COUNT(*) FILTER (WHERE last_date_time >= now() - interval '60 days' AND last_date_time < now() - interval '30 days')::bigint as previous_period_count
FROM sessions
`

type GetSessionStatsRow struct {
	Total               int64 `json:"total"`
	RecentCount         int64 `json:"recent_count"`
	CurrentPeriodCount  int64 `json:"current_period_count"`
	PreviousPeriodCount int64 `json:"previous_period_count"`
}

func (q *Queries) GetSessionStats(ctx context.Context) (GetSessionStatsRow, error) {
	row := q.db.QueryRow(ctx, getSessionStats)
	var i GetSessionStatsRow
	err := row.Scan(
		&i.Total,
		&i.RecentCount,
		&i.CurrentPeriodCount,
		&i.PreviousPeriodCount,
	)
	return i, err
}
