// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: entities.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createEntity = `-- name: CreateEntity :one
INSERT INTO entities (
    name,
    type,
    description,
    properties,
    updated_at
) VALUES (
    $1,
    $2,
    $3,
    $4,
    NOW()
)
RETURNING entity_id, name, type, description, properties, created_at, updated_at, deleted_at
`

type CreateEntityParams struct {
	Name        string  `json:"name"`
	Type        string  `json:"type"`
	Description *string `json:"description"`
	Properties  []byte  `json:"properties"`
}

func (q *Queries) CreateEntity(ctx context.Context, arg CreateEntityParams) (Entity, error) {
	row := q.db.QueryRow(ctx, createEntity,
		arg.Name,
		arg.Type,
		arg.Description,
		arg.Properties,
	)
	var i Entity
	err := row.Scan(
		&i.EntityID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createEntityRelationship = `-- name: CreateEntityRelationship :one
INSERT INTO entity_relationships (
    entity_id,
    related_type,
    related_id,
    relationship_type,
    metadata
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, entity_id, related_type, related_id, relationship_type, metadata, created_at, updated_at
`

type CreateEntityRelationshipParams struct {
	EntityID         uuid.UUID `json:"entity_id"`
	RelatedType      string    `json:"related_type"`
	RelatedID        uuid.UUID `json:"related_id"`
	RelationshipType string    `json:"relationship_type"`
	Metadata         []byte    `json:"metadata"`
}

func (q *Queries) CreateEntityRelationship(ctx context.Context, arg CreateEntityRelationshipParams) (EntityRelationship, error) {
	row := q.db.QueryRow(ctx, createEntityRelationship,
		arg.EntityID,
		arg.RelatedType,
		arg.RelatedID,
		arg.RelationshipType,
		arg.Metadata,
	)
	var i EntityRelationship
	err := row.Scan(
		&i.ID,
		&i.EntityID,
		&i.RelatedType,
		&i.RelatedID,
		&i.RelationshipType,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEntity = `-- name: DeleteEntity :exec
UPDATE entities
SET
    deleted_at = NOW(),
    updated_at = NOW()
WHERE entity_id = $1
`

func (q *Queries) DeleteEntity(ctx context.Context, entityID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEntity, entityID)
	return err
}

const deleteEntityRelationship = `-- name: DeleteEntityRelationship :exec
DELETE FROM entity_relationships
WHERE id = $1
`

func (q *Queries) DeleteEntityRelationship(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteEntityRelationship, id)
	return err
}

const getEntity = `-- name: GetEntity :one
SELECT
    entity_id,
    name,
    type,
    description,
    properties,
    created_at,
    updated_at,
    deleted_at
FROM entities
WHERE entity_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetEntity(ctx context.Context, entityID uuid.UUID) (Entity, error) {
	row := q.db.QueryRow(ctx, getEntity, entityID)
	var i Entity
	err := row.Scan(
		&i.EntityID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getEntityReferences = `-- name: GetEntityReferences :many
SELECT
    id,
    source_type,
    source_id,
    entity_id,
    reference_text,
    position,
    created_at
FROM entity_references
WHERE entity_id = $1
`

func (q *Queries) GetEntityReferences(ctx context.Context, entityID uuid.UUID) ([]EntityReference, error) {
	rows, err := q.db.Query(ctx, getEntityReferences, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntityReference{}
	for rows.Next() {
		var i EntityReference
		if err := rows.Scan(
			&i.ID,
			&i.SourceType,
			&i.SourceID,
			&i.EntityID,
			&i.ReferenceText,
			&i.Position,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityReferencesBySourceType = `-- name: GetEntityReferencesBySourceType :many
SELECT
    id,
    source_type,
    source_id,
    entity_id,
    reference_text,
    position,
    created_at
FROM entity_references
WHERE entity_id = $1
  AND source_type = $2
`

type GetEntityReferencesBySourceTypeParams struct {
	EntityID   uuid.UUID `json:"entity_id"`
	SourceType string    `json:"source_type"`
}

func (q *Queries) GetEntityReferencesBySourceType(ctx context.Context, arg GetEntityReferencesBySourceTypeParams) ([]EntityReference, error) {
	rows, err := q.db.Query(ctx, getEntityReferencesBySourceType, arg.EntityID, arg.SourceType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntityReference{}
	for rows.Next() {
		var i EntityReference
		if err := rows.Scan(
			&i.ID,
			&i.SourceType,
			&i.SourceID,
			&i.EntityID,
			&i.ReferenceText,
			&i.Position,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityRelationshipsByEntity = `-- name: GetEntityRelationshipsByEntity :many
SELECT
    id,
    entity_id,
    related_type,
    related_id,
    relationship_type,
    metadata,
    created_at,
    updated_at
FROM entity_relationships
WHERE entity_id = $1
`

func (q *Queries) GetEntityRelationshipsByEntity(ctx context.Context, entityID uuid.UUID) ([]EntityRelationship, error) {
	rows, err := q.db.Query(ctx, getEntityRelationshipsByEntity, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntityRelationship{}
	for rows.Next() {
		var i EntityRelationship
		if err := rows.Scan(
			&i.ID,
			&i.EntityID,
			&i.RelatedType,
			&i.RelatedID,
			&i.RelationshipType,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntityRelationshipsByTypeAndRelationship = `-- name: GetEntityRelationshipsByTypeAndRelationship :many
SELECT
    id,
    entity_id,
    related_type,
    related_id,
    relationship_type,
    metadata,
    created_at,
    updated_at
FROM entity_relationships
WHERE entity_id = $1
  AND related_type = $2
  AND relationship_type = $3
`

type GetEntityRelationshipsByTypeAndRelationshipParams struct {
	EntityID         uuid.UUID `json:"entity_id"`
	RelatedType      string    `json:"related_type"`
	RelationshipType string    `json:"relationship_type"`
}

func (q *Queries) GetEntityRelationshipsByTypeAndRelationship(ctx context.Context, arg GetEntityRelationshipsByTypeAndRelationshipParams) ([]EntityRelationship, error) {
	rows, err := q.db.Query(ctx, getEntityRelationshipsByTypeAndRelationship, arg.EntityID, arg.RelatedType, arg.RelationshipType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EntityRelationship{}
	for rows.Next() {
		var i EntityRelationship
		if err := rows.Scan(
			&i.ID,
			&i.EntityID,
			&i.RelatedType,
			&i.RelatedID,
			&i.RelationshipType,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeletedEntities = `-- name: ListDeletedEntities :many
SELECT
    entity_id,
    name,
    type,
    description,
    properties,
    created_at,
    updated_at,
    deleted_at
FROM entities
WHERE deleted_at IS NOT NULL
ORDER BY deleted_at DESC
`

func (q *Queries) ListDeletedEntities(ctx context.Context) ([]Entity, error) {
	rows, err := q.db.Query(ctx, listDeletedEntities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Entity{}
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.EntityID,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.Properties,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEntities = `-- name: ListEntities :many
SELECT
    entity_id,
    name,
    type,
    description,
    properties,
    created_at,
    updated_at,
    deleted_at
FROM entities
WHERE deleted_at IS NULL
  AND ($1 = '' OR type = $1)
  AND ($2::timestamp IS NULL OR updated_at >= $2)
ORDER BY name
`

type ListEntitiesParams struct {
	Column1 interface{}      `json:"column_1"`
	Column2 pgtype.Timestamp `json:"column_2"`
}

func (q *Queries) ListEntities(ctx context.Context, arg ListEntitiesParams) ([]Entity, error) {
	rows, err := q.db.Query(ctx, listEntities, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Entity{}
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.EntityID,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.Properties,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchEntities = `-- name: SearchEntities :many
SELECT
    entity_id,
    name,
    type,
    description,
    properties,
    created_at,
    updated_at,
    deleted_at
FROM entities
WHERE deleted_at IS NULL
  AND name ILIKE '%' || $1 || '%'
  AND ($2 = '' OR type = $2)
ORDER BY name
`

type SearchEntitiesParams struct {
	Column1 *string     `json:"column_1"`
	Column2 interface{} `json:"column_2"`
}

func (q *Queries) SearchEntities(ctx context.Context, arg SearchEntitiesParams) ([]Entity, error) {
	rows, err := q.db.Query(ctx, searchEntities, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Entity{}
	for rows.Next() {
		var i Entity
		if err := rows.Scan(
			&i.EntityID,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.Properties,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateContactNameByRelationship = `-- name: UpdateContactNameByRelationship :exec
UPDATE contacts
SET
    name = $3,
    last_update = NOW()
WHERE contact_id IN (
    SELECT related_id
    FROM entity_relationships
    WHERE entity_id = $1
      AND related_type = 'contact'
      AND relationship_type = $2
)
`

type UpdateContactNameByRelationshipParams struct {
	EntityID         uuid.UUID `json:"entity_id"`
	RelationshipType string    `json:"relationship_type"`
	Name             string    `json:"name"`
}

func (q *Queries) UpdateContactNameByRelationship(ctx context.Context, arg UpdateContactNameByRelationshipParams) error {
	_, err := q.db.Exec(ctx, updateContactNameByRelationship, arg.EntityID, arg.RelationshipType, arg.Name)
	return err
}

const updateEntity = `-- name: UpdateEntity :one
UPDATE entities
SET
    name = COALESCE($2, name),
    type = COALESCE($3, type),
    description = COALESCE($4, description),
    properties = COALESCE($5, properties),
    updated_at = NOW()
WHERE entity_id = $1 AND deleted_at IS NULL
RETURNING entity_id, name, type, description, properties, created_at, updated_at, deleted_at
`

type UpdateEntityParams struct {
	EntityID    uuid.UUID `json:"entity_id"`
	Name        string    `json:"name"`
	Type        string    `json:"type"`
	Description *string   `json:"description"`
	Properties  []byte    `json:"properties"`
}

func (q *Queries) UpdateEntity(ctx context.Context, arg UpdateEntityParams) (Entity, error) {
	row := q.db.QueryRow(ctx, updateEntity,
		arg.EntityID,
		arg.Name,
		arg.Type,
		arg.Description,
		arg.Properties,
	)
	var i Entity
	err := row.Scan(
		&i.EntityID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
