// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: categories.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCategorySource = `-- name: CreateCategorySource :one
INSERT INTO category_sources (
    category_id,
    source_uri,
    raw_source
) VALUES (
    $1, $2, $3
) RETURNING id, category_id, source_uri, raw_source
`

type CreateCategorySourceParams struct {
	CategoryID pgtype.UUID `json:"category_id"`
	SourceUri  *string     `json:"source_uri"`
	RawSource  []byte      `json:"raw_source"`
}

func (q *Queries) CreateCategorySource(ctx context.Context, arg CreateCategorySourceParams) (CategorySource, error) {
	row := q.db.QueryRow(ctx, createCategorySource, arg.CategoryID, arg.SourceUri, arg.RawSource)
	var i CategorySource
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.SourceUri,
		&i.RawSource,
	)
	return i, err
}

const deleteCategorySource = `-- name: DeleteCategorySource :exec
DELETE FROM category_sources
WHERE id = $1
`

func (q *Queries) DeleteCategorySource(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCategorySource, id)
	return err
}

const getCategory = `-- name: GetCategory :one
SELECT
    category_id,
    name
FROM categories
WHERE category_id = $1
`

func (q *Queries) GetCategory(ctx context.Context, categoryID uuid.UUID) (Category, error) {
	row := q.db.QueryRow(ctx, getCategory, categoryID)
	var i Category
	err := row.Scan(&i.CategoryID, &i.Name)
	return i, err
}

const getCategorySource = `-- name: GetCategorySource :one
SELECT
    id,
    category_id,
    source_uri,
    raw_source
FROM category_sources
WHERE id = $1
`

func (q *Queries) GetCategorySource(ctx context.Context, id uuid.UUID) (CategorySource, error) {
	row := q.db.QueryRow(ctx, getCategorySource, id)
	var i CategorySource
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.SourceUri,
		&i.RawSource,
	)
	return i, err
}

const listCategoriesWithSources = `-- name: ListCategoriesWithSources :many
SELECT
    c.category_id,
    c.name,
    COALESCE(
        json_agg(
            json_build_object(
                'id', s.id,
                'category_id', s.category_id,
                'source_uri', s.source_uri,
                'raw_source', s.raw_source
            )
        ) FILTER (WHERE s.id IS NOT NULL),
        '[]'::json
    ) as sources
FROM categories c
LEFT JOIN category_sources s ON c.category_id = s.category_id
GROUP BY c.category_id, c.name
ORDER BY c.name
`

type ListCategoriesWithSourcesRow struct {
	CategoryID uuid.UUID   `json:"category_id"`
	Name       string      `json:"name"`
	Sources    interface{} `json:"sources"`
}

func (q *Queries) ListCategoriesWithSources(ctx context.Context) ([]ListCategoriesWithSourcesRow, error) {
	rows, err := q.db.Query(ctx, listCategoriesWithSources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCategoriesWithSourcesRow{}
	for rows.Next() {
		var i ListCategoriesWithSourcesRow
		if err := rows.Scan(&i.CategoryID, &i.Name, &i.Sources); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergeCategories = `-- name: MergeCategories :exec
CALL merge_categories($1::uuid, $2::uuid)
`

type MergeCategoriesParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 uuid.UUID `json:"column_2"`
}

func (q *Queries) MergeCategories(ctx context.Context, arg MergeCategoriesParams) error {
	_, err := q.db.Exec(ctx, mergeCategories, arg.Column1, arg.Column2)
	return err
}

const updateCategory = `-- name: UpdateCategory :exec
UPDATE categories
SET name = $2
WHERE category_id = $1
`

type UpdateCategoryParams struct {
	CategoryID uuid.UUID `json:"category_id"`
	Name       string    `json:"name"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) error {
	_, err := q.db.Exec(ctx, updateCategory, arg.CategoryID, arg.Name)
	return err
}

const updateCategorySource = `-- name: UpdateCategorySource :exec
UPDATE category_sources
SET
    source_uri = $2,
    raw_source = $3
WHERE id = $1
`

type UpdateCategorySourceParams struct {
	ID        uuid.UUID `json:"id"`
	SourceUri *string   `json:"source_uri"`
	RawSource []byte    `json:"raw_source"`
}

func (q *Queries) UpdateCategorySource(ctx context.Context, arg UpdateCategorySourceParams) error {
	_, err := q.db.Exec(ctx, updateCategorySource, arg.ID, arg.SourceUri, arg.RawSource)
	return err
}
