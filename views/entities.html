<div class="page-layout entities-page">
    <!-- Page Header -->
    <div class="page-header">
        <div class="page-header-row">
            <div class="page-header-content">
                <h1 class="page-title">Knowledge Graph</h1>
                <p class="page-description">Explore entities and their relationships</p>
            </div>
            <div class="page-header-actions">
                <div class="view-toggle">
                    <button class="btn btn-secondary view-toggle-btn active" data-view="graph" onclick="entitiesView.setView('graph')">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="3"/>
                            <circle cx="4" cy="6" r="2"/>
                            <circle cx="20" cy="6" r="2"/>
                            <circle cx="4" cy="18" r="2"/>
                            <circle cx="20" cy="18" r="2"/>
                            <line x1="9.5" y1="10.5" x2="5.5" y2="7.5"/>
                            <line x1="14.5" y1="10.5" x2="18.5" y2="7.5"/>
                            <line x1="9.5" y1="13.5" x2="5.5" y2="16.5"/>
                            <line x1="14.5" y1="13.5" x2="18.5" y2="16.5"/>
                        </svg>
                        Graph
                    </button>
                    <button class="btn btn-secondary view-toggle-btn" data-view="list" onclick="entitiesView.setView('list')">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="8" y1="6" x2="21" y2="6"/>
                            <line x1="8" y1="12" x2="21" y2="12"/>
                            <line x1="8" y1="18" x2="21" y2="18"/>
                            <line x1="3" y1="6" x2="3.01" y2="6"/>
                            <line x1="3" y1="12" x2="3.01" y2="12"/>
                            <line x1="3" y1="18" x2="3.01" y2="18"/>
                        </svg>
                        List
                    </button>
                </div>
                <button class="btn btn-primary" onclick="entitiesView.openAddEntityModal()">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"/>
                        <line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                    Add Entity
                </button>
            </div>
        </div>
    </div>

    <!-- Search and Filter Bar -->
    <div class="filter-bar entities-toolbar">
        <div class="search-box entity-search-box">
            <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"/>
                <line x1="21" y1="21" x2="16.65" y2="16.65"/>
            </svg>
            <input type="text" class="search-input" placeholder="Search entities..." id="entity-search" oninput="entitiesView.handleSearch(this.value)">
            <div class="search-autocomplete" id="search-autocomplete"></div>
        </div>
        <select class="form-select entity-type-filter" id="type-filter" onchange="entitiesView.filterByType(this.value)">
            <option value="">All Types</option>
            <option value="person">Person</option>
            <option value="place">Place</option>
            <option value="concept">Concept</option>
            <option value="technology">Technology</option>
            <option value="organization">Organization</option>
            <option value="project">Project</option>
            <option value="event">Event</option>
        </select>
    </div>

    <!-- Main Content Area -->
    <div class="entities-container">
        <!-- Graph View -->
        <div class="graph-container" id="graph-container">
            <!-- Graph Controls -->
            <div class="graph-controls">
                <button class="graph-control-btn" onclick="entitiesView.zoomIn()" title="Zoom In">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/>
                        <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                        <line x1="11" y1="8" x2="11" y2="14"/>
                        <line x1="8" y1="11" x2="14" y2="11"/>
                    </svg>
                </button>
                <button class="graph-control-btn" onclick="entitiesView.zoomOut()" title="Zoom Out">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"/>
                        <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                        <line x1="8" y1="11" x2="14" y2="11"/>
                    </svg>
                </button>
                <button class="graph-control-btn" onclick="entitiesView.fitToScreen()" title="Fit to Screen">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M8 3H5a2 2 0 0 0-2 2v3"/>
                        <path d="M21 8V5a2 2 0 0 0-2-2h-3"/>
                        <path d="M3 16v3a2 2 0 0 0 2 2h3"/>
                        <path d="M16 21h3a2 2 0 0 0 2-2v-3"/>
                    </svg>
                </button>
                <button class="graph-control-btn" onclick="entitiesView.resetLayout()" title="Reset Layout">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                        <path d="M3 3v5h5"/>
                    </svg>
                </button>
                <div class="graph-control-divider"></div>
                <button class="graph-control-btn" id="toggle-labels-btn" onclick="entitiesView.toggleLabels()" title="Toggle Labels">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>
                    </svg>
                </button>
                <button class="graph-control-btn" id="toggle-edge-labels-btn" onclick="entitiesView.toggleEdgeLabels()" title="Toggle Relationship Labels">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="4" y1="9" x2="20" y2="9"/>
                        <line x1="4" y1="15" x2="20" y2="15"/>
                        <line x1="10" y1="3" x2="8" y2="21"/>
                        <line x1="16" y1="3" x2="14" y2="21"/>
                    </svg>
                </button>
                <div class="graph-control-divider"></div>
                <button class="graph-control-btn" onclick="entitiesView.exportSVG()" title="Export as SVG">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="7,10 12,15 17,10"/>
                        <line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                </button>
                <button class="graph-control-btn" onclick="entitiesView.exportPNG()" title="Export as PNG">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <circle cx="8.5" cy="8.5" r="1.5"/>
                        <polyline points="21,15 16,10 5,21"/>
                    </svg>
                </button>
            </div>

            <!-- SVG Graph Canvas -->
            <svg id="graph-svg" class="graph-svg">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#666"/>
                    </marker>
                    <filter id="glow">
                        <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                        <feMerge>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                    <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                        <feDropShadow dx="0" dy="2" stdDeviation="3" flood-opacity="0.3"/>
                    </filter>
                </defs>
                <g id="graph-viewport">
                    <g id="edges-layer"></g>
                    <g id="nodes-layer"></g>
                </g>
            </svg>

            <!-- Entity Type Legend -->
            <div class="graph-legend" id="graph-legend">
                <div class="legend-title">Entity Types</div>
                <div class="legend-items" id="legend-items"></div>
            </div>

            <!-- Graph Stats -->
            <div class="graph-stats" id="graph-stats">
                <span id="node-count">0 nodes</span>
                <span class="stats-divider">|</span>
                <span id="edge-count">0 relationships</span>
            </div>
        </div>

        <!-- List View -->
        <div class="list-container" id="list-container" style="display: none;">
            <div class="list-toolbar">
                <div class="sort-controls">
                    <label class="form-label" style="margin-bottom: 0; margin-right: var(--space-2);">Sort by:</label>
                    <select class="form-select" id="sort-select" onchange="entitiesView.handleSort(this.value)">
                        <option value="name-asc">Name (A-Z)</option>
                        <option value="name-desc">Name (Z-A)</option>
                        <option value="type">Type</option>
                        <option value="connections-desc">Most Connections</option>
                        <option value="connections-asc">Least Connections</option>
                        <option value="date-desc">Newest First</option>
                        <option value="date-asc">Oldest First</option>
                    </select>
                </div>
            </div>
            <div class="entities-list" id="entities-list"></div>
        </div>

        <!-- Entity Detail Panel -->
        <div class="entity-detail-panel" id="entity-detail-panel">
            <div class="detail-panel-header">
                <h3 class="detail-panel-title" id="detail-entity-name">Select an Entity</h3>
                <button class="btn btn-ghost btn-sm" onclick="entitiesView.closeDetailPanel()">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            <div class="detail-panel-content" id="detail-panel-content">
                <div class="empty-detail-state">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="12" y1="8" x2="12" y2="12"/>
                        <line x1="12" y1="16" x2="12.01" y2="16"/>
                    </svg>
                    <p>Click on an entity in the graph or list to view its details</p>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
/* Entities Page Styles */
.entities-page {
    display: flex;
    flex-direction: column;
    height: calc(100vh - var(--top-bar-height) - var(--space-12));
}

.entities-toolbar {
    display: flex;
    gap: var(--space-4);
    align-items: center;
}

.entity-search-box {
    flex: 1;
    max-width: 400px;
    position: relative;
}

.search-autocomplete {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: var(--color-background-elevated);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    margin-top: var(--space-1);
    max-height: 300px;
    overflow-y: auto;
    z-index: var(--z-dropdown);
    display: none;
}

.search-autocomplete.active {
    display: block;
}

.autocomplete-item {
    display: flex;
    align-items: center;
    gap: var(--space-3);
    padding: var(--space-3);
    cursor: pointer;
    transition: background-color var(--transition-fast);
}

.autocomplete-item:hover {
    background-color: var(--color-background-hover);
}

.autocomplete-item .entity-type-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
}

.entity-type-filter {
    width: 150px;
}

/* View Toggle */
.view-toggle {
    display: flex;
    gap: 0;
}

.view-toggle-btn {
    border-radius: 0;
}

.view-toggle-btn:first-child {
    border-radius: var(--radius-md) 0 0 var(--radius-md);
}

.view-toggle-btn:last-child {
    border-radius: 0 var(--radius-md) var(--radius-md) 0;
    border-left: none;
}

.view-toggle-btn.active {
    background-color: var(--color-accent);
    border-color: var(--color-accent);
}

/* Entities Container */
.entities-container {
    flex: 1;
    display: flex;
    gap: var(--space-4);
    min-height: 0;
}

/* Graph Container */
.graph-container {
    flex: 1;
    position: relative;
    background: var(--color-background-elevated);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    overflow: hidden;
}

.graph-svg {
    width: 100%;
    height: 100%;
    cursor: grab;
}

.graph-svg.grabbing {
    cursor: grabbing;
}

/* Graph Controls */
.graph-controls {
    position: absolute;
    top: var(--space-4);
    left: var(--space-4);
    display: flex;
    flex-direction: column;
    gap: var(--space-2);
    background: var(--color-background-elevated);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-2);
    z-index: 10;
}

.graph-control-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 36px;
    color: var(--color-text-secondary);
    border-radius: var(--radius-md);
    transition: all var(--transition-fast);
}

.graph-control-btn:hover {
    background-color: var(--color-background-hover);
    color: var(--color-text-primary);
}

.graph-control-btn.active {
    background-color: var(--color-accent-light);
    color: var(--color-accent);
}

.graph-control-divider {
    height: 1px;
    background: var(--color-border);
    margin: var(--space-1) 0;
}

/* Graph Legend */
.graph-legend {
    position: absolute;
    bottom: var(--space-4);
    left: var(--space-4);
    background: var(--color-background-elevated);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-3);
    z-index: 10;
    min-width: 160px;
}

.legend-title {
    font-size: var(--font-size-xs);
    font-weight: var(--font-weight-semibold);
    color: var(--color-text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: var(--space-2);
}

.legend-items {
    display: flex;
    flex-direction: column;
    gap: var(--space-2);
}

.legend-item {
    display: flex;
    align-items: center;
    gap: var(--space-2);
    padding: var(--space-1) var(--space-2);
    border-radius: var(--radius-sm);
    cursor: pointer;
    transition: background-color var(--transition-fast);
    font-size: var(--font-size-sm);
}

.legend-item:hover {
    background-color: var(--color-background-hover);
}

.legend-item.inactive {
    opacity: 0.5;
}

.legend-item .legend-color {
    width: 12px;
    height: 12px;
    border-radius: 50%;
}

.legend-item .legend-label {
    flex: 1;
    text-transform: capitalize;
}

.legend-item .legend-count {
    color: var(--color-text-tertiary);
    font-size: var(--font-size-xs);
}

/* Graph Stats */
.graph-stats {
    position: absolute;
    bottom: var(--space-4);
    right: var(--space-4);
    background: var(--color-background-elevated);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-2) var(--space-3);
    font-size: var(--font-size-sm);
    color: var(--color-text-secondary);
    z-index: 10;
}

.stats-divider {
    margin: 0 var(--space-2);
    color: var(--color-border);
}

/* Graph Node Styles */
.graph-node {
    cursor: pointer;
    transition: filter 0.2s ease;
}

.graph-node:hover {
    filter: url(#glow);
}

.graph-node.selected circle {
    stroke: var(--color-accent);
    stroke-width: 3;
}

.graph-node.highlighted circle {
    stroke: var(--color-warning);
    stroke-width: 3;
}

.graph-node.dimmed {
    opacity: 0.3;
}

.node-label {
    font-size: 11px;
    fill: var(--color-text-primary);
    pointer-events: none;
    text-anchor: middle;
    dominant-baseline: middle;
}

.node-label.hidden {
    display: none;
}

/* Graph Edge Styles */
.graph-edge {
    stroke: var(--color-border);
    stroke-width: 1.5;
    fill: none;
    transition: stroke var(--transition-fast), stroke-width var(--transition-fast);
}

.graph-edge.highlighted {
    stroke: var(--color-accent);
    stroke-width: 2.5;
}

.graph-edge.dimmed {
    opacity: 0.2;
}

.edge-label {
    font-size: 10px;
    fill: var(--color-text-tertiary);
    pointer-events: none;
    text-anchor: middle;
}

.edge-label.hidden {
    display: none;
}

/* List Container */
.list-container {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.list-toolbar {
    display: flex;
    justify-content: flex-end;
    padding: var(--space-3);
    background: var(--color-background-elevated);
    border: 1px solid var(--color-border);
    border-bottom: none;
    border-radius: var(--radius-lg) var(--radius-lg) 0 0;
}

.sort-controls {
    display: flex;
    align-items: center;
}

.sort-controls .form-select {
    width: auto;
}

.entities-list {
    flex: 1;
    background: var(--color-background-elevated);
    border: 1px solid var(--color-border);
    border-radius: 0 0 var(--radius-lg) var(--radius-lg);
    overflow-y: auto;
}

.entity-list-item {
    display: flex;
    align-items: center;
    gap: var(--space-4);
    padding: var(--space-4);
    border-bottom: 1px solid var(--color-border);
    cursor: pointer;
    transition: background-color var(--transition-fast);
}

.entity-list-item:hover {
    background-color: var(--color-background-hover);
}

.entity-list-item:last-child {
    border-bottom: none;
}

.entity-list-item.selected {
    background-color: var(--color-accent-light);
}

.entity-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: var(--font-weight-semibold);
    font-size: var(--font-size-sm);
    color: white;
}

.entity-info {
    flex: 1;
    min-width: 0;
}

.entity-name {
    font-weight: var(--font-weight-medium);
    margin-bottom: var(--space-1);
}

.entity-description {
    font-size: var(--font-size-sm);
    color: var(--color-text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.entity-meta {
    display: flex;
    align-items: center;
    gap: var(--space-3);
}

.entity-type-badge {
    padding: var(--space-1) var(--space-2);
    border-radius: var(--radius-full);
    font-size: var(--font-size-xs);
    font-weight: var(--font-weight-medium);
    text-transform: capitalize;
}

.entity-connections {
    font-size: var(--font-size-sm);
    color: var(--color-text-tertiary);
}

/* Entity Detail Panel */
.entity-detail-panel {
    width: 360px;
    background: var(--color-background-elevated);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.detail-panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--space-4);
    border-bottom: 1px solid var(--color-border);
}

.detail-panel-title {
    font-size: var(--font-size-lg);
    font-weight: var(--font-weight-semibold);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.detail-panel-content {
    flex: 1;
    overflow-y: auto;
    padding: var(--space-4);
}

.empty-detail-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    text-align: center;
    color: var(--color-text-tertiary);
    padding: var(--space-8);
}

.empty-detail-state svg {
    margin-bottom: var(--space-4);
}

.empty-detail-state p {
    font-size: var(--font-size-sm);
}

/* Detail Panel Entity View */
.detail-entity-header {
    display: flex;
    align-items: center;
    gap: var(--space-4);
    margin-bottom: var(--space-6);
}

.detail-avatar {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: var(--font-weight-bold);
    font-size: var(--font-size-xl);
    color: white;
}

.detail-entity-info {
    flex: 1;
}

.detail-entity-type {
    display: inline-block;
    padding: var(--space-1) var(--space-2);
    border-radius: var(--radius-full);
    font-size: var(--font-size-xs);
    font-weight: var(--font-weight-medium);
    text-transform: capitalize;
    margin-bottom: var(--space-2);
}

.detail-entity-name {
    font-size: var(--font-size-xl);
    font-weight: var(--font-weight-semibold);
}

.detail-section {
    margin-bottom: var(--space-6);
}

.detail-section-title {
    font-size: var(--font-size-xs);
    font-weight: var(--font-weight-semibold);
    color: var(--color-text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: var(--space-3);
}

.detail-description {
    font-size: var(--font-size-sm);
    color: var(--color-text-secondary);
    line-height: var(--line-height-relaxed);
}

.detail-description-edit {
    width: 100%;
    min-height: 80px;
    padding: var(--space-2);
    background: var(--color-background);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    color: var(--color-text-primary);
    font-size: var(--font-size-sm);
    resize: vertical;
}

.detail-relationships {
    display: flex;
    flex-direction: column;
    gap: var(--space-2);
}

.relationship-item {
    display: flex;
    align-items: center;
    gap: var(--space-2);
    padding: var(--space-2);
    background: var(--color-background);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    font-size: var(--font-size-sm);
    cursor: pointer;
    transition: background-color var(--transition-fast);
}

.relationship-item:hover {
    background-color: var(--color-background-hover);
}

.relationship-direction {
    color: var(--color-text-tertiary);
    font-size: var(--font-size-xs);
}

.relationship-type {
    color: var(--color-accent);
    font-size: var(--font-size-xs);
}

.relationship-entity {
    flex: 1;
    font-weight: var(--font-weight-medium);
}

.relationship-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
}

.detail-references {
    display: flex;
    flex-direction: column;
    gap: var(--space-2);
}

.reference-item {
    display: flex;
    align-items: center;
    gap: var(--space-2);
    padding: var(--space-2);
    background: var(--color-background);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    font-size: var(--font-size-sm);
    cursor: pointer;
    transition: background-color var(--transition-fast);
}

.reference-item:hover {
    background-color: var(--color-background-hover);
}

.reference-icon {
    color: var(--color-text-tertiary);
}

.reference-title {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.detail-actions {
    display: flex;
    gap: var(--space-2);
    margin-top: var(--space-4);
    padding-top: var(--space-4);
    border-top: 1px solid var(--color-border);
}

.detail-actions .btn {
    flex: 1;
}

/* Entity Type Colors */
.type-person { background-color: #f97316; }
.type-place { background-color: #22c55e; }
.type-concept { background-color: #a855f7; }
.type-technology { background-color: #3b82f6; }
.type-organization { background-color: #06b6d4; }
.type-project { background-color: #eab308; }
.type-event { background-color: #ec4899; }

.type-badge-person { background-color: rgba(249, 115, 22, 0.15); color: #f97316; }
.type-badge-place { background-color: rgba(34, 197, 94, 0.15); color: #22c55e; }
.type-badge-concept { background-color: rgba(168, 85, 247, 0.15); color: #a855f7; }
.type-badge-technology { background-color: rgba(59, 130, 246, 0.15); color: #3b82f6; }
.type-badge-organization { background-color: rgba(6, 182, 212, 0.15); color: #06b6d4; }
.type-badge-project { background-color: rgba(234, 179, 8, 0.15); color: #eab308; }
.type-badge-event { background-color: rgba(236, 72, 153, 0.15); color: #ec4899; }

/* Responsive */
@media (max-width: 1024px) {
    .entities-container {
        flex-direction: column;
    }

    .entity-detail-panel {
        width: 100%;
        max-height: 400px;
    }

    .graph-container {
        min-height: 500px;
    }
}

@media (max-width: 768px) {
    .entities-toolbar {
        flex-direction: column;
        align-items: stretch;
    }

    .entity-search-box {
        max-width: none;
    }

    .entity-type-filter {
        width: 100%;
    }

    .entity-detail-panel {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        max-width: 400px;
        z-index: var(--z-modal);
        transform: translateX(100%);
        transition: transform var(--transition-base);
        border-radius: 0;
    }

    .entity-detail-panel.open {
        transform: translateX(0);
    }
}
</style>

<script>
// Entity View Controller
class EntitiesView {
    constructor() {
        this.entities = [];
        this.relationships = [];
        this.nodes = [];
        this.edges = [];
        this.selectedEntity = null;
        this.currentView = 'graph';
        this.typeFilter = '';
        this.searchQuery = '';
        this.sortBy = 'name-asc';

        // Graph state
        this.zoom = 1;
        this.panX = 0;
        this.panY = 0;
        this.isDragging = false;
        this.isPanning = false;
        this.draggedNode = null;
        this.showLabels = true;
        this.showEdgeLabels = false;
        this.animationRunning = false;

        // Force simulation parameters
        this.repulsionForce = 5000;
        this.attractionForce = 0.05;
        this.damping = 0.85;
        this.minDistance = 80;

        // Type colors
        this.typeColors = {
            person: '#f97316',
            place: '#22c55e',
            concept: '#a855f7',
            technology: '#3b82f6',
            organization: '#06b6d4',
            project: '#eab308',
            event: '#ec4899'
        };

        // Relationship types
        this.relationshipTypes = [
            'is related to',
            'works at',
            'works with',
            'created by',
            'created',
            'part of',
            'contains',
            'uses',
            'depends on',
            'influenced by',
            'located in',
            'attended',
            'organized by'
        ];

        this.init();
    }

    async init() {
        await this.loadData();
        this.setupEventListeners();
        this.renderLegend();
        this.renderGraph();
        this.startSimulation();
    }

    async loadData() {
        try {
            const result = await app.api.getEntities({ pageSize: 100 });
            this.entities = result.data || [];

            // Generate relationships between entities for demo
            this.generateRelationships();

            // Create nodes and edges
            this.createGraphData();
        } catch (error) {
            console.error('Failed to load entities:', error);
            app.toast.error('Failed to load entities');
        }
    }

    generateRelationships() {
        // Create some demo relationships between entities
        this.relationships = [];
        const types = this.relationshipTypes;

        // Technology relationships
        this.addRelationship('React', 'TypeScript', 'uses');
        this.addRelationship('React', 'Vercel', 'deployed on');
        this.addRelationship('GraphQL', 'React', 'used with');
        this.addRelationship('Kubernetes', 'Redis', 'orchestrates');
        this.addRelationship('PostgreSQL', 'Redis', 'complemented by');

        // Organization relationships
        this.addRelationship('OpenAI', 'Acme Corp', 'partners with');
        this.addRelationship('Vercel', 'React', 'supports');

        // Project relationships
        this.addRelationship('Q1 Product Launch', 'React', 'uses');
        this.addRelationship('Q1 Product Launch', 'TypeScript', 'uses');
        this.addRelationship('Q1 Product Launch', 'Acme Corp', 'owned by');
        this.addRelationship('API Redesign', 'GraphQL', 'uses');
        this.addRelationship('API Redesign', 'PostgreSQL', 'uses');
        this.addRelationship('API Redesign', 'Acme Corp', 'owned by');

        // Event relationships
        this.addRelationship('TechConf 2024', 'React', 'features');
        this.addRelationship('TechConf 2024', 'OpenAI', 'sponsored by');
        this.addRelationship('TechConf 2024', 'Kubernetes', 'covers');
    }

    addRelationship(sourceName, targetName, type) {
        const source = this.entities.find(e => e.name === sourceName);
        const target = this.entities.find(e => e.name === targetName);

        if (source && target) {
            this.relationships.push({
                source: source.entity_id,
                target: target.entity_id,
                type: type
            });
        }
    }

    createGraphData() {
        const svg = document.getElementById('graph-svg');
        const width = svg.clientWidth || 800;
        const height = svg.clientHeight || 600;
        const centerX = width / 2;
        const centerY = height / 2;

        // Create nodes with random initial positions
        this.nodes = this.entities.map((entity, i) => {
            const angle = (i / this.entities.length) * 2 * Math.PI;
            const radius = Math.min(width, height) / 3;
            return {
                id: entity.entity_id,
                entity: entity,
                x: centerX + radius * Math.cos(angle) + (Math.random() - 0.5) * 100,
                y: centerY + radius * Math.sin(angle) + (Math.random() - 0.5) * 100,
                vx: 0,
                vy: 0,
                radius: 20,
                fixed: false
            };
        });

        // Calculate node sizes based on connections
        const connectionCounts = {};
        this.relationships.forEach(rel => {
            connectionCounts[rel.source] = (connectionCounts[rel.source] || 0) + 1;
            connectionCounts[rel.target] = (connectionCounts[rel.target] || 0) + 1;
        });

        this.nodes.forEach(node => {
            const connections = connectionCounts[node.id] || 0;
            node.connections = connections;
            node.radius = 15 + Math.min(connections * 3, 20);
        });

        // Create edges
        this.edges = this.relationships.map(rel => {
            const source = this.nodes.find(n => n.id === rel.source);
            const target = this.nodes.find(n => n.id === rel.target);
            return {
                source: source,
                target: target,
                type: rel.type
            };
        }).filter(edge => edge.source && edge.target);

        // Update stats
        document.getElementById('node-count').textContent = `${this.nodes.length} nodes`;
        document.getElementById('edge-count').textContent = `${this.edges.length} relationships`;
    }

    setupEventListeners() {
        const svg = document.getElementById('graph-svg');

        // Pan and zoom
        svg.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        svg.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        svg.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        svg.addEventListener('mouseleave', (e) => this.handleMouseUp(e));
        svg.addEventListener('wheel', (e) => this.handleWheel(e));

        // Touch events for mobile
        svg.addEventListener('touchstart', (e) => this.handleTouchStart(e));
        svg.addEventListener('touchmove', (e) => this.handleTouchMove(e));
        svg.addEventListener('touchend', (e) => this.handleTouchEnd(e));

        // Close search autocomplete when clicking outside
        document.addEventListener('click', (e) => {
            const autocomplete = document.getElementById('search-autocomplete');
            const searchInput = document.getElementById('entity-search');
            if (!autocomplete.contains(e.target) && e.target !== searchInput) {
                autocomplete.classList.remove('active');
            }
        });
    }

    handleMouseDown(e) {
        const svg = document.getElementById('graph-svg');

        if (e.target.closest('.graph-node')) {
            // Node drag
            const nodeGroup = e.target.closest('.graph-node');
            const nodeId = nodeGroup.dataset.id;
            this.draggedNode = this.nodes.find(n => n.id === nodeId);
            if (this.draggedNode) {
                this.draggedNode.fixed = true;
                this.isDragging = true;
            }
        } else {
            // Pan
            this.isPanning = true;
            this.lastMouseX = e.clientX;
            this.lastMouseY = e.clientY;
            svg.classList.add('grabbing');
        }
    }

    handleMouseMove(e) {
        if (this.isDragging && this.draggedNode) {
            const svg = document.getElementById('graph-svg');
            const rect = svg.getBoundingClientRect();
            const x = (e.clientX - rect.left - this.panX) / this.zoom;
            const y = (e.clientY - rect.top - this.panY) / this.zoom;
            this.draggedNode.x = x;
            this.draggedNode.y = y;
            this.renderGraph();
        } else if (this.isPanning) {
            const dx = e.clientX - this.lastMouseX;
            const dy = e.clientY - this.lastMouseY;
            this.panX += dx;
            this.panY += dy;
            this.lastMouseX = e.clientX;
            this.lastMouseY = e.clientY;
            this.updateViewport();
        }
    }

    handleMouseUp(e) {
        const svg = document.getElementById('graph-svg');
        if (this.draggedNode) {
            this.draggedNode.fixed = false;
            this.draggedNode = null;
        }
        this.isDragging = false;
        this.isPanning = false;
        svg.classList.remove('grabbing');
    }

    handleWheel(e) {
        e.preventDefault();
        const svg = document.getElementById('graph-svg');
        const rect = svg.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.max(0.1, Math.min(5, this.zoom * zoomDelta));

        // Zoom towards mouse position
        this.panX = mouseX - (mouseX - this.panX) * (newZoom / this.zoom);
        this.panY = mouseY - (mouseY - this.panY) * (newZoom / this.zoom);
        this.zoom = newZoom;

        this.updateViewport();
    }

    handleTouchStart(e) {
        if (e.touches.length === 1) {
            this.handleMouseDown({
                target: e.target,
                clientX: e.touches[0].clientX,
                clientY: e.touches[0].clientY
            });
        }
    }

    handleTouchMove(e) {
        if (e.touches.length === 1) {
            e.preventDefault();
            this.handleMouseMove({
                clientX: e.touches[0].clientX,
                clientY: e.touches[0].clientY
            });
        }
    }

    handleTouchEnd(e) {
        this.handleMouseUp(e);
    }

    updateViewport() {
        const viewport = document.getElementById('graph-viewport');
        viewport.setAttribute('transform', `translate(${this.panX}, ${this.panY}) scale(${this.zoom})`);
    }

    // Force-directed layout simulation
    startSimulation() {
        if (this.animationRunning) return;
        this.animationRunning = true;
        this.simulate();
    }

    stopSimulation() {
        this.animationRunning = false;
    }

    simulate() {
        if (!this.animationRunning) return;

        const svg = document.getElementById('graph-svg');
        const width = svg.clientWidth || 800;
        const height = svg.clientHeight || 600;

        // Apply forces
        this.applyForces(width, height);

        // Update velocities and positions
        let totalMovement = 0;
        this.nodes.forEach(node => {
            if (!node.fixed) {
                node.vx *= this.damping;
                node.vy *= this.damping;
                node.x += node.vx;
                node.y += node.vy;
                totalMovement += Math.abs(node.vx) + Math.abs(node.vy);
            }
        });

        // Render
        this.renderGraph();

        // Continue simulation if still moving significantly
        if (totalMovement > 0.1) {
            requestAnimationFrame(() => this.simulate());
        } else {
            this.animationRunning = false;
        }
    }

    applyForces(width, height) {
        // Repulsion between all nodes
        for (let i = 0; i < this.nodes.length; i++) {
            for (let j = i + 1; j < this.nodes.length; j++) {
                const nodeA = this.nodes[i];
                const nodeB = this.nodes[j];

                let dx = nodeB.x - nodeA.x;
                let dy = nodeB.y - nodeA.y;
                let distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 1) distance = 1;

                const force = this.repulsionForce / (distance * distance);
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;

                if (!nodeA.fixed) {
                    nodeA.vx -= fx;
                    nodeA.vy -= fy;
                }
                if (!nodeB.fixed) {
                    nodeB.vx += fx;
                    nodeB.vy += fy;
                }
            }
        }

        // Attraction along edges
        this.edges.forEach(edge => {
            const source = edge.source;
            const target = edge.target;

            let dx = target.x - source.x;
            let dy = target.y - source.y;
            let distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 1) distance = 1;

            const force = (distance - this.minDistance) * this.attractionForce;
            const fx = (dx / distance) * force;
            const fy = (dy / distance) * force;

            if (!source.fixed) {
                source.vx += fx;
                source.vy += fy;
            }
            if (!target.fixed) {
                target.vx -= fx;
                target.vy -= fy;
            }
        });

        // Center gravity
        const centerX = width / 2;
        const centerY = height / 2;
        this.nodes.forEach(node => {
            if (!node.fixed) {
                node.vx += (centerX - node.x) * 0.001;
                node.vy += (centerY - node.y) * 0.001;
            }
        });

        // Boundary constraints
        this.nodes.forEach(node => {
            const padding = 50;
            if (node.x < padding) node.vx += 1;
            if (node.x > width - padding) node.vx -= 1;
            if (node.y < padding) node.vy += 1;
            if (node.y > height - padding) node.vy -= 1;
        });
    }

    renderGraph() {
        const filteredNodes = this.getFilteredNodes();
        const filteredNodeIds = new Set(filteredNodes.map(n => n.id));
        const filteredEdges = this.edges.filter(e =>
            filteredNodeIds.has(e.source.id) && filteredNodeIds.has(e.target.id)
        );

        this.renderEdges(filteredEdges);
        this.renderNodes(filteredNodes);
    }

    renderNodes(nodes) {
        const nodesLayer = document.getElementById('nodes-layer');

        nodesLayer.innerHTML = nodes.map(node => {
            const color = this.typeColors[node.entity.type] || '#888';
            const isSelected = this.selectedEntity && this.selectedEntity.entity_id === node.id;
            const isHighlighted = this.highlightedNodes && this.highlightedNodes.has(node.id);
            const isDimmed = this.highlightedNodes && !this.highlightedNodes.has(node.id);

            let className = 'graph-node';
            if (isSelected) className += ' selected';
            if (isHighlighted) className += ' highlighted';
            if (isDimmed) className += ' dimmed';

            return `
                <g class="${className}"
                   data-id="${node.id}"
                   transform="translate(${node.x}, ${node.y})"
                   onclick="entitiesView.selectEntity('${node.id}')"
                   ondblclick="entitiesView.focusEntity('${node.id}')">
                    <circle r="${node.radius}" fill="${color}" filter="url(#shadow)"/>
                    <text class="node-label ${this.showLabels ? '' : 'hidden'}" y="${node.radius + 14}">
                        ${Utils.truncate(node.entity.name, 15)}
                    </text>
                </g>
            `;
        }).join('');
    }

    renderEdges(edges) {
        const edgesLayer = document.getElementById('edges-layer');

        edgesLayer.innerHTML = edges.map(edge => {
            const isHighlighted = this.highlightedEdges && this.highlightedEdges.has(edge);
            const isDimmed = this.highlightedEdges && !this.highlightedEdges.has(edge);

            let className = 'graph-edge';
            if (isHighlighted) className += ' highlighted';
            if (isDimmed) className += ' dimmed';

            // Calculate edge path (straight line for now)
            const sx = edge.source.x;
            const sy = edge.source.y;
            const tx = edge.target.x;
            const ty = edge.target.y;

            // Shorten path to not overlap with node circles
            const angle = Math.atan2(ty - sy, tx - sx);
            const sourceRadius = edge.source.radius + 2;
            const targetRadius = edge.target.radius + 2;

            const x1 = sx + Math.cos(angle) * sourceRadius;
            const y1 = sy + Math.sin(angle) * sourceRadius;
            const x2 = tx - Math.cos(angle) * targetRadius;
            const y2 = ty - Math.sin(angle) * targetRadius;

            // Midpoint for label
            const mx = (x1 + x2) / 2;
            const my = (y1 + y2) / 2;

            return `
                <g class="edge-group">
                    <line class="${className}"
                          x1="${x1}" y1="${y1}"
                          x2="${x2}" y2="${y2}"
                          marker-end="url(#arrowhead)"/>
                    <text class="edge-label ${this.showEdgeLabels ? '' : 'hidden'}"
                          x="${mx}" y="${my - 5}">
                        ${edge.type}
                    </text>
                </g>
            `;
        }).join('');
    }

    renderLegend() {
        const legendItems = document.getElementById('legend-items');
        const typeCounts = {};

        this.entities.forEach(entity => {
            typeCounts[entity.type] = (typeCounts[entity.type] || 0) + 1;
        });

        const types = Object.keys(this.typeColors);
        legendItems.innerHTML = types.map(type => {
            const count = typeCounts[type] || 0;
            const isActive = !this.typeFilter || this.typeFilter === type;
            return `
                <div class="legend-item ${isActive ? '' : 'inactive'}"
                     onclick="entitiesView.toggleTypeFilter('${type}')">
                    <div class="legend-color" style="background-color: ${this.typeColors[type]}"></div>
                    <span class="legend-label">${type}</span>
                    <span class="legend-count">${count}</span>
                </div>
            `;
        }).join('');
    }

    renderList() {
        const container = document.getElementById('entities-list');
        const filteredEntities = this.getFilteredEntities();
        const sortedEntities = this.sortEntities(filteredEntities);

        if (sortedEntities.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <svg class="empty-state-icon" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <line x1="8" y1="12" x2="16" y2="12"/>
                    </svg>
                    <h3 class="empty-state-title">No entities found</h3>
                    <p class="empty-state-description">Try adjusting your filters or search query</p>
                </div>
            `;
            return;
        }

        container.innerHTML = sortedEntities.map(entity => {
            const node = this.nodes.find(n => n.id === entity.entity_id);
            const connections = node ? node.connections : 0;
            const isSelected = this.selectedEntity && this.selectedEntity.entity_id === entity.entity_id;

            return `
                <div class="entity-list-item ${isSelected ? 'selected' : ''}"
                     onclick="entitiesView.selectEntityById('${entity.entity_id}')">
                    <div class="entity-avatar type-${entity.type}">
                        ${Utils.getInitials(entity.name)}
                    </div>
                    <div class="entity-info">
                        <div class="entity-name">${Utils.escapeHtml(entity.name)}</div>
                        <div class="entity-description">${Utils.escapeHtml(entity.description || 'No description')}</div>
                    </div>
                    <div class="entity-meta">
                        <span class="entity-type-badge type-badge-${entity.type}">${entity.type}</span>
                        <span class="entity-connections">${connections} connections</span>
                    </div>
                </div>
            `;
        }).join('');
    }

    getFilteredNodes() {
        let nodes = this.nodes;

        if (this.typeFilter) {
            nodes = nodes.filter(n => n.entity.type === this.typeFilter);
        }

        if (this.searchQuery) {
            const query = this.searchQuery.toLowerCase();
            nodes = nodes.filter(n =>
                n.entity.name.toLowerCase().includes(query) ||
                (n.entity.description && n.entity.description.toLowerCase().includes(query))
            );
        }

        return nodes;
    }

    getFilteredEntities() {
        let entities = this.entities;

        if (this.typeFilter) {
            entities = entities.filter(e => e.type === this.typeFilter);
        }

        if (this.searchQuery) {
            const query = this.searchQuery.toLowerCase();
            entities = entities.filter(e =>
                e.name.toLowerCase().includes(query) ||
                (e.description && e.description.toLowerCase().includes(query))
            );
        }

        return entities;
    }

    sortEntities(entities) {
        const [field, direction] = this.sortBy.split('-');

        return [...entities].sort((a, b) => {
            let comparison = 0;

            switch (field) {
                case 'name':
                    comparison = a.name.localeCompare(b.name);
                    break;
                case 'type':
                    comparison = a.type.localeCompare(b.type);
                    break;
                case 'connections':
                    const nodeA = this.nodes.find(n => n.id === a.entity_id);
                    const nodeB = this.nodes.find(n => n.id === b.entity_id);
                    comparison = (nodeA?.connections || 0) - (nodeB?.connections || 0);
                    break;
                case 'date':
                    comparison = new Date(a.created_at) - new Date(b.created_at);
                    break;
            }

            return direction === 'desc' ? -comparison : comparison;
        });
    }

    // View Controls
    setView(view) {
        this.currentView = view;

        document.querySelectorAll('.view-toggle-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.view === view);
        });

        document.getElementById('graph-container').style.display = view === 'graph' ? 'block' : 'none';
        document.getElementById('list-container').style.display = view === 'list' ? 'flex' : 'none';

        if (view === 'list') {
            this.renderList();
        } else {
            this.renderGraph();
        }
    }

    filterByType(type) {
        this.typeFilter = type;
        this.renderLegend();

        if (this.currentView === 'graph') {
            this.renderGraph();
        } else {
            this.renderList();
        }
    }

    toggleTypeFilter(type) {
        if (this.typeFilter === type) {
            this.typeFilter = '';
            document.getElementById('type-filter').value = '';
        } else {
            this.typeFilter = type;
            document.getElementById('type-filter').value = type;
        }

        this.renderLegend();

        if (this.currentView === 'graph') {
            this.renderGraph();
        } else {
            this.renderList();
        }
    }

    handleSearch(query) {
        this.searchQuery = query;

        // Show autocomplete
        const autocomplete = document.getElementById('search-autocomplete');
        if (query.length > 0) {
            const matches = this.entities.filter(e =>
                e.name.toLowerCase().includes(query.toLowerCase())
            ).slice(0, 8);

            if (matches.length > 0) {
                autocomplete.innerHTML = matches.map(entity => `
                    <div class="autocomplete-item" onclick="entitiesView.selectFromAutocomplete('${entity.entity_id}')">
                        <div class="entity-type-dot" style="background-color: ${this.typeColors[entity.type]}"></div>
                        <span>${Utils.escapeHtml(entity.name)}</span>
                    </div>
                `).join('');
                autocomplete.classList.add('active');
            } else {
                autocomplete.classList.remove('active');
            }
        } else {
            autocomplete.classList.remove('active');
        }

        // Highlight matching nodes
        if (query) {
            const matchingIds = new Set(this.entities
                .filter(e => e.name.toLowerCase().includes(query.toLowerCase()))
                .map(e => e.entity_id)
            );
            this.highlightedNodes = matchingIds;
        } else {
            this.highlightedNodes = null;
        }

        if (this.currentView === 'graph') {
            this.renderGraph();
        } else {
            this.renderList();
        }
    }

    selectFromAutocomplete(entityId) {
        document.getElementById('search-autocomplete').classList.remove('active');
        document.getElementById('entity-search').value = '';
        this.searchQuery = '';
        this.highlightedNodes = null;
        this.selectEntity(entityId);
        this.focusEntity(entityId);
    }

    handleSort(value) {
        this.sortBy = value;
        if (this.currentView === 'list') {
            this.renderList();
        }
    }

    // Graph Controls
    zoomIn() {
        this.zoom = Math.min(5, this.zoom * 1.2);
        this.updateViewport();
    }

    zoomOut() {
        this.zoom = Math.max(0.1, this.zoom / 1.2);
        this.updateViewport();
    }

    fitToScreen() {
        const svg = document.getElementById('graph-svg');
        const width = svg.clientWidth;
        const height = svg.clientHeight;

        if (this.nodes.length === 0) return;

        // Calculate bounds
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;

        this.nodes.forEach(node => {
            minX = Math.min(minX, node.x - node.radius);
            maxX = Math.max(maxX, node.x + node.radius);
            minY = Math.min(minY, node.y - node.radius);
            maxY = Math.max(maxY, node.y + node.radius);
        });

        const graphWidth = maxX - minX;
        const graphHeight = maxY - minY;
        const padding = 50;

        this.zoom = Math.min(
            (width - padding * 2) / graphWidth,
            (height - padding * 2) / graphHeight,
            2
        );

        this.panX = (width - graphWidth * this.zoom) / 2 - minX * this.zoom;
        this.panY = (height - graphHeight * this.zoom) / 2 - minY * this.zoom;

        this.updateViewport();
    }

    resetLayout() {
        this.zoom = 1;
        this.panX = 0;
        this.panY = 0;
        this.updateViewport();

        // Re-randomize positions and restart simulation
        const svg = document.getElementById('graph-svg');
        const width = svg.clientWidth || 800;
        const height = svg.clientHeight || 600;
        const centerX = width / 2;
        const centerY = height / 2;

        this.nodes.forEach((node, i) => {
            const angle = (i / this.nodes.length) * 2 * Math.PI;
            const radius = Math.min(width, height) / 3;
            node.x = centerX + radius * Math.cos(angle) + (Math.random() - 0.5) * 100;
            node.y = centerY + radius * Math.sin(angle) + (Math.random() - 0.5) * 100;
            node.vx = 0;
            node.vy = 0;
        });

        this.startSimulation();
    }

    toggleLabels() {
        this.showLabels = !this.showLabels;
        document.getElementById('toggle-labels-btn').classList.toggle('active', this.showLabels);
        this.renderGraph();
    }

    toggleEdgeLabels() {
        this.showEdgeLabels = !this.showEdgeLabels;
        document.getElementById('toggle-edge-labels-btn').classList.toggle('active', this.showEdgeLabels);
        this.renderGraph();
    }

    exportSVG() {
        const svg = document.getElementById('graph-svg');
        const clone = svg.cloneNode(true);

        // Add styles inline
        const styles = document.querySelector('style').textContent;
        const styleEl = document.createElementNS('http://www.w3.org/2000/svg', 'style');
        styleEl.textContent = styles;
        clone.insertBefore(styleEl, clone.firstChild);

        const data = new XMLSerializer().serializeToString(clone);
        const blob = new Blob([data], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = 'knowledge-graph.svg';
        a.click();

        URL.revokeObjectURL(url);
        app.toast.success('SVG exported successfully');
    }

    exportPNG() {
        const svg = document.getElementById('graph-svg');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = svg.clientWidth * 2;
        canvas.height = svg.clientHeight * 2;
        ctx.scale(2, 2);

        const data = new XMLSerializer().serializeToString(svg);
        const img = new Image();

        img.onload = () => {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);

            const a = document.createElement('a');
            a.href = canvas.toDataURL('image/png');
            a.download = 'knowledge-graph.png';
            a.click();

            app.toast.success('PNG exported successfully');
        };

        img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(data)));
    }

    // Entity Selection
    selectEntity(entityId) {
        const entity = this.entities.find(e => e.entity_id === entityId);
        if (entity) {
            this.selectedEntity = entity;
            this.highlightConnectedNodes(entityId);
            this.renderGraph();
            this.renderDetailPanel(entity);

            if (this.currentView === 'list') {
                this.renderList();
            }
        }
    }

    selectEntityById(entityId) {
        this.selectEntity(entityId);
    }

    focusEntity(entityId) {
        const node = this.nodes.find(n => n.id === entityId);
        if (node) {
            const svg = document.getElementById('graph-svg');
            const width = svg.clientWidth;
            const height = svg.clientHeight;

            this.panX = width / 2 - node.x * this.zoom;
            this.panY = height / 2 - node.y * this.zoom;
            this.updateViewport();
        }
    }

    highlightConnectedNodes(entityId) {
        const connectedNodeIds = new Set([entityId]);
        const connectedEdges = new Set();

        this.edges.forEach(edge => {
            if (edge.source.id === entityId) {
                connectedNodeIds.add(edge.target.id);
                connectedEdges.add(edge);
            } else if (edge.target.id === entityId) {
                connectedNodeIds.add(edge.source.id);
                connectedEdges.add(edge);
            }
        });

        this.highlightedNodes = connectedNodeIds;
        this.highlightedEdges = connectedEdges;
    }

    renderDetailPanel(entity) {
        const node = this.nodes.find(n => n.id === entity.entity_id);
        const connections = node ? node.connections : 0;

        // Find relationships
        const outgoing = this.relationships.filter(r => r.source === entity.entity_id);
        const incoming = this.relationships.filter(r => r.target === entity.entity_id);

        document.getElementById('detail-entity-name').textContent = entity.name;

        document.getElementById('detail-panel-content').innerHTML = `
            <div class="detail-entity-header">
                <div class="detail-avatar type-${entity.type}">
                    ${Utils.getInitials(entity.name)}
                </div>
                <div class="detail-entity-info">
                    <span class="detail-entity-type type-badge-${entity.type}">${entity.type}</span>
                    <div class="detail-entity-name">${Utils.escapeHtml(entity.name)}</div>
                </div>
            </div>

            <div class="detail-section">
                <div class="detail-section-title">Description</div>
                <p class="detail-description">${Utils.escapeHtml(entity.description || 'No description available')}</p>
            </div>

            <div class="detail-section">
                <div class="detail-section-title">Relationships (${outgoing.length + incoming.length})</div>
                <div class="detail-relationships">
                    ${outgoing.map(rel => {
                        const target = this.entities.find(e => e.entity_id === rel.target);
                        return target ? `
                            <div class="relationship-item" onclick="entitiesView.selectEntity('${target.entity_id}')">
                                <span class="relationship-direction">-></span>
                                <span class="relationship-type">${rel.type}</span>
                                <span class="relationship-entity">${Utils.escapeHtml(target.name)}</span>
                                <div class="relationship-dot" style="background-color: ${this.typeColors[target.type]}"></div>
                            </div>
                        ` : '';
                    }).join('')}
                    ${incoming.map(rel => {
                        const source = this.entities.find(e => e.entity_id === rel.source);
                        return source ? `
                            <div class="relationship-item" onclick="entitiesView.selectEntity('${source.entity_id}')">
                                <span class="relationship-direction"><-</span>
                                <span class="relationship-type">${rel.type}</span>
                                <span class="relationship-entity">${Utils.escapeHtml(source.name)}</span>
                                <div class="relationship-dot" style="background-color: ${this.typeColors[source.type]}"></div>
                            </div>
                        ` : '';
                    }).join('')}
                    ${(outgoing.length + incoming.length) === 0 ? '<p class="text-muted text-sm">No relationships yet</p>' : ''}
                </div>
            </div>

            <div class="detail-section">
                <div class="detail-section-title">Properties</div>
                ${entity.properties ? `
                    <div class="detail-properties">
                        ${Object.entries(entity.properties).map(([key, value]) => `
                            <div class="property-item">
                                <span class="property-key">${key}:</span>
                                <span class="property-value">${value}</span>
                            </div>
                        `).join('')}
                    </div>
                ` : '<p class="text-muted text-sm">No additional properties</p>'}
            </div>

            <div class="detail-section">
                <div class="detail-section-title">Metadata</div>
                <p class="text-sm text-muted">Created: ${Utils.formatDateTime(entity.created_at)}</p>
                <p class="text-sm text-muted">Updated: ${Utils.formatDateTime(entity.updated_at)}</p>
            </div>

            <div class="detail-actions">
                <button class="btn btn-secondary" onclick="entitiesView.openAddRelationshipModal('${entity.entity_id}')">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"/>
                        <line x1="5" y1="12" x2="19" y2="12"/>
                    </svg>
                    Add Relationship
                </button>
                <button class="btn btn-secondary" onclick="entitiesView.openEditEntityModal('${entity.entity_id}')">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>
                    </svg>
                    Edit
                </button>
            </div>
        `;

        // Open panel on mobile
        document.getElementById('entity-detail-panel').classList.add('open');
    }

    closeDetailPanel() {
        this.selectedEntity = null;
        this.highlightedNodes = null;
        this.highlightedEdges = null;

        document.getElementById('detail-entity-name').textContent = 'Select an Entity';
        document.getElementById('detail-panel-content').innerHTML = `
            <div class="empty-detail-state">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <circle cx="12" cy="12" r="10"/>
                    <line x1="12" y1="8" x2="12" y2="12"/>
                    <line x1="12" y1="16" x2="12.01" y2="16"/>
                </svg>
                <p>Click on an entity in the graph or list to view its details</p>
            </div>
        `;

        document.getElementById('entity-detail-panel').classList.remove('open');
        this.renderGraph();

        if (this.currentView === 'list') {
            this.renderList();
        }
    }

    // Modals
    openAddEntityModal() {
        app.modal.open({
            title: 'Add New Entity',
            content: `
                <div class="form-group">
                    <label class="form-label">Name *</label>
                    <input type="text" class="form-input" id="new-entity-name" placeholder="Entity name" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Type *</label>
                    <select class="form-select" id="new-entity-type">
                        <option value="person">Person</option>
                        <option value="place">Place</option>
                        <option value="concept">Concept</option>
                        <option value="technology" selected>Technology</option>
                        <option value="organization">Organization</option>
                        <option value="project">Project</option>
                        <option value="event">Event</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-textarea" id="new-entity-description" placeholder="Brief description..." rows="3"></textarea>
                </div>
            `,
            footer: `
                <button class="btn btn-secondary" onclick="app.modal.close()">Cancel</button>
                <button class="btn btn-primary" onclick="entitiesView.createEntity()">Create Entity</button>
            `
        });
    }

    async createEntity() {
        const name = document.getElementById('new-entity-name').value.trim();
        const type = document.getElementById('new-entity-type').value;
        const description = document.getElementById('new-entity-description').value.trim();

        if (!name) {
            app.toast.warning('Please enter an entity name');
            return;
        }

        try {
            const newEntity = await app.api.createEntity({
                name,
                type,
                description
            });

            app.modal.close();
            app.toast.success(`Entity "${name}" created successfully`);

            // Reload data
            await this.loadData();
            this.renderGraph();
            this.renderLegend();
            this.startSimulation();
        } catch (error) {
            app.toast.error('Failed to create entity');
        }
    }

    openEditEntityModal(entityId) {
        const entity = this.entities.find(e => e.entity_id === entityId);
        if (!entity) return;

        app.modal.open({
            title: 'Edit Entity',
            content: `
                <div class="form-group">
                    <label class="form-label">Name *</label>
                    <input type="text" class="form-input" id="edit-entity-name" value="${Utils.escapeHtml(entity.name)}" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Type *</label>
                    <select class="form-select" id="edit-entity-type">
                        <option value="person" ${entity.type === 'person' ? 'selected' : ''}>Person</option>
                        <option value="place" ${entity.type === 'place' ? 'selected' : ''}>Place</option>
                        <option value="concept" ${entity.type === 'concept' ? 'selected' : ''}>Concept</option>
                        <option value="technology" ${entity.type === 'technology' ? 'selected' : ''}>Technology</option>
                        <option value="organization" ${entity.type === 'organization' ? 'selected' : ''}>Organization</option>
                        <option value="project" ${entity.type === 'project' ? 'selected' : ''}>Project</option>
                        <option value="event" ${entity.type === 'event' ? 'selected' : ''}>Event</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-textarea" id="edit-entity-description" rows="3">${Utils.escapeHtml(entity.description || '')}</textarea>
                </div>
            `,
            footer: `
                <button class="btn btn-danger" onclick="entitiesView.deleteEntity('${entityId}')" style="margin-right: auto;">Delete</button>
                <button class="btn btn-secondary" onclick="app.modal.close()">Cancel</button>
                <button class="btn btn-primary" onclick="entitiesView.updateEntity('${entityId}')">Save Changes</button>
            `
        });
    }

    async updateEntity(entityId) {
        const name = document.getElementById('edit-entity-name').value.trim();
        const type = document.getElementById('edit-entity-type').value;
        const description = document.getElementById('edit-entity-description').value.trim();

        if (!name) {
            app.toast.warning('Please enter an entity name');
            return;
        }

        // Update local data (in real app, would call API)
        const entity = this.entities.find(e => e.entity_id === entityId);
        if (entity) {
            entity.name = name;
            entity.type = type;
            entity.description = description;
            entity.updated_at = new Date().toISOString();
        }

        app.modal.close();
        app.toast.success('Entity updated successfully');

        // Re-render
        this.createGraphData();
        this.renderGraph();
        this.renderLegend();

        if (this.selectedEntity && this.selectedEntity.entity_id === entityId) {
            this.renderDetailPanel(entity);
        }
    }

    async deleteEntity(entityId) {
        const confirmed = await app.modal.confirm(
            'Are you sure you want to delete this entity? This action cannot be undone.',
            { title: 'Delete Entity', confirmText: 'Delete', type: 'danger' }
        );

        if (confirmed) {
            // Remove from local data (in real app, would call API)
            this.entities = this.entities.filter(e => e.entity_id !== entityId);
            this.relationships = this.relationships.filter(r =>
                r.source !== entityId && r.target !== entityId
            );

            app.toast.success('Entity deleted successfully');

            this.closeDetailPanel();
            this.createGraphData();
            this.renderGraph();
            this.renderLegend();
            this.startSimulation();
        }
    }

    openAddRelationshipModal(sourceEntityId) {
        const sourceEntity = this.entities.find(e => e.entity_id === sourceEntityId);
        const otherEntities = this.entities.filter(e => e.entity_id !== sourceEntityId);

        app.modal.open({
            title: 'Add Relationship',
            content: `
                <div class="form-group">
                    <label class="form-label">From</label>
                    <input type="text" class="form-input" value="${Utils.escapeHtml(sourceEntity.name)}" disabled>
                </div>
                <div class="form-group">
                    <label class="form-label">Relationship Type *</label>
                    <select class="form-select" id="relationship-type">
                        ${this.relationshipTypes.map(type => `
                            <option value="${type}">${type}</option>
                        `).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">To *</label>
                    <select class="form-select" id="relationship-target">
                        <option value="">Select entity...</option>
                        ${otherEntities.map(entity => `
                            <option value="${entity.entity_id}">${Utils.escapeHtml(entity.name)} (${entity.type})</option>
                        `).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label class="flex items-center gap-2">
                        <input type="checkbox" id="relationship-bidirectional">
                        <span>Bidirectional relationship</span>
                    </label>
                    <p class="form-helper">Creates relationship in both directions</p>
                </div>
            `,
            footer: `
                <button class="btn btn-secondary" onclick="app.modal.close()">Cancel</button>
                <button class="btn btn-primary" onclick="entitiesView.createRelationship('${sourceEntityId}')">Create Relationship</button>
            `
        });
    }

    createRelationship(sourceId) {
        const type = document.getElementById('relationship-type').value;
        const targetId = document.getElementById('relationship-target').value;
        const bidirectional = document.getElementById('relationship-bidirectional').checked;

        if (!targetId) {
            app.toast.warning('Please select a target entity');
            return;
        }

        // Add relationship
        this.relationships.push({
            source: sourceId,
            target: targetId,
            type: type
        });

        if (bidirectional) {
            this.relationships.push({
                source: targetId,
                target: sourceId,
                type: type
            });
        }

        app.modal.close();
        app.toast.success('Relationship created successfully');

        // Re-render
        this.createGraphData();
        this.renderGraph();
        this.startSimulation();

        if (this.selectedEntity) {
            this.renderDetailPanel(this.selectedEntity);
        }
    }
}

// Initialize when loaded
let entitiesView;
document.addEventListener('DOMContentLoaded', () => {
    // Will be initialized when the view is loaded
});

// Initialize immediately if DOM is ready
if (document.getElementById('graph-svg')) {
    entitiesView = new EntitiesView();
} else {
    // Wait for view to load
    setTimeout(() => {
        entitiesView = new EntitiesView();
    }, 100);
}
</script>
